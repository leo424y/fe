<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>我的職業是前端工程師 – </title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="style.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <meta name="viewport" content="width=device-width">
</head>
<body>
<h1>我的職業是前端工程師</h1>
<p>By <a href="https://www.phodal.com/">Phodal</a> (Follow Me: <a href="http://weibo.com/phodal">微博</a>、<a href="https://www.zhihu.com/people/phodal">知乎</a>、<a href="https://segmentfault.com/u/phodal">SegmentFault</a>)
</p>

<p>我的其他電子書：</p>
<ul>
<li>《<a href="https://github.com/phodal/ideabook">Phodal's Idea實戰指南</a>》</li>
<li>《<a href="https://github.com/phodal/designiot">一步步搭建物聯網系統</a>》</li>
<li>《<a href="https://github.com/phodal/github-roam">GitHub 漫遊指南</a>》</li>
<li>《<a href="https://github.com/phodal/repractise">RePractise</a>》</li>
<li>《<a href="https://github.com/phodal/growth-ebook">Growth: 全棧增長工程師指南</a>》</li>
<li>《<a href="https://github.com/phodal/growth-in-action">Growth: 全棧增長工程師實戰</a>》</li>
</ul>

<p>微信公眾號</p>
<p><img src="http://articles.phodal.com/qrcode.jpg" alt=""/></p>
<p>
當前為預覽版，在使用的過程中遇到任何遇到請及時與我聯絡。閱讀過程中問題，不煩在GitHub上提出來：
<a href="https://github.com/phodal/fe/issues">Issues</a>
</p>
<p>
閱讀過程中遇到語法錯誤、拼寫錯誤、技術錯誤等等，不煩來個Pull Request，這樣可以幫助到其他閱讀這本電子書的童鞋。
</p>

<div style="width:800px">

<iframe src="http://ghbtns.com/github-btn.html?user=phodal&repo=fe&type=watch&count=true"
        allowtransparency="true" frameborder="0" scrolling="0" width="110px" height="20px"></iframe>
</div>
<nav id="TOC">
<ul>
<li><a href="#序為什麼前端沒有前途">序:為什麼前端沒有前途？</a></li>
<li><a href="#我要成為一個前端設計師">我要成為一個前端設計師</a><ul>
<li><a href="#漂亮的前臺">漂亮的前臺</a></li>
<li><a href="#我要成為一個前端設計師-1">我要成為一個前端設計師</a></li>
<li><a href="#關於我的職業是前端工程師">關於《我的職業是前端工程師》</a></li>
</ul></li>
<li><a href="#入門不是應該很簡單嗎">入門不是應該很簡單嗎？</a><ul>
<li><a href="#前端之路">前端之路</a></li>
<li><a href="#我的前端入門">我的前端入門</a><ul>
<li><a href="#我的第一個網站">我的第一個網站</a></li>
<li><a href="#copypaste-from-cookbook">Copy/Paste from Cookbook</a></li>
<li><a href="#開發工具">開發工具</a></li>
<li><a href="#jquery-是最好用的">jQuery 是最好用的</a></li>
</ul></li>
</ul></li>
<li><a href="#學習前端只需要三個月語言篇">學習前端只需要三個月【語言篇】</a><ul>
<li><a href="#javascript-語言的變化">JavaScript 語言的變化</a><ul>
<li><a href="#javascript">JavaScript</a></li>
<li><a href="#es6">ES6+</a></li>
<li><a href="#typescript">TypeScript</a></li>
</ul></li>
<li><a href="#小結">小結</a></li>
</ul></li>
<li><a href="#如何選擇合適的前端框架告別選擇恐懼症">如何選擇合適的前端框架，告別選擇恐懼症</a><ul>
<li><a href="#前端的選擇恐懼症">前端的選擇恐懼症</a><ul>
<li><a href="#技術選型不僅僅受技術影響">技術選型：不僅僅受技術影響</a></li>
<li><a href="#上線時間影響框架">上線時間影響框架</a></li>
<li><a href="#錘子定律你需要更大的視野">錘子定律：你需要更大的視野</a></li>
</ul></li>
<li><a href="#前端框架一覽">前端框架一覽</a><ul>
<li><a href="#jquery-使用生態解決問題">jQuery, 使用生態解決問題</a></li>
<li><a href="#backbone.js脊椎連線框架">Backbone.js，脊椎連線框架</a></li>
<li><a href="#angular一站式提高生產力">Angular，一站式提高生產力</a></li>
<li><a href="#react元件化提高複用">React，元件化提高複用</a></li>
<li><a href="#vue.js簡單也是提高效率">Vue.js，簡單也是提高效率</a></li>
<li><a href="#小結-1">小結</a></li>
</ul></li>
<li><a href="#總結">總結</a></li>
</ul></li>
<li><a href="#前端工程師必會的六個偵錯技能">前端工程師必會的六個偵錯技能</a><ul>
<li><a href="#我的偵錯入門">我的偵錯入門</a></li>
<li><a href="#基本偵錯技巧實時偵錯">基本偵錯技巧：實時偵錯</a><ul>
<li><a href="#實時偵錯樣式">實時偵錯樣式</a></li>
<li><a href="#實時偵錯程式碼">實時偵錯程式碼</a></li>
</ul></li>
<li><a href="#移動裝置偵錯">移動裝置偵錯</a><ul>
<li><a href="#模擬真機裝置模擬器">模擬真機：裝置模擬器</a></li>
<li><a href="#真機偵錯device-inspect">真機偵錯：Device Inspect</a></li>
</ul></li>
<li><a href="#網路偵錯">網路偵錯</a><ul>
<li><a href="#網路偵錯-1">網路偵錯</a></li>
<li><a href="#使用外掛">使用外掛</a></li>
</ul></li>
<li><a href="#小結-2">小結</a></li>
</ul></li>
<li><a href="#如何以正確的姿勢練習深化前端知識">如何以正確的姿勢練習，深化前端知識</a><ul>
<li><a href="#前端項目的練習過程">前端項目的練習過程</a><ul>
<li><a href="#output-is-input">Output is Input</a></li>
<li><a href="#練習框架技術的時機">練習框架、技術的時機</a></li>
</ul></li>
<li><a href="#練習的過程">練習的過程</a></li>
<li><a href="#練習框架技術的技巧">練習框架、技術的技巧</a><ul>
<li><a href="#使用模板">使用模板</a></li>
<li><a href="#做點什麼應用">做點什麼應用</a></li>
<li><a href="#編寫一個部落格應用">編寫一個部落格應用</a></li>
<li><a href="#輸入和總結">輸入和總結</a></li>
</ul></li>
<li><a href="#其它">其它</a><ul>
<li><a href="#關於練手項目">關於練手項目</a></li>
</ul></li>
</ul></li>
<li><a href="#前後端分離你應該知道的八件事">前後端分離，你應該知道的八件事</a><ul>
<li><a href="#前後端分離">前後端分離</a><ul>
<li><a href="#什麼是前後端分離">什麼是前後端分離？</a></li>
<li><a href="#真的需要前後端分離嗎">真的需要前後端分離嗎？</a></li>
<li><a href="#前後端分離將遇到的那些挑戰">前後端分離將遇到的那些挑戰</a></li>
</ul></li>
<li><a href="#前後端分離的核心後臺提供資料前端負責顯示">前後端分離的核心：後臺提供資料，前端負責顯示</a><ul>
<li><a href="#輸出邏輯資料顯示">輸出邏輯：資料顯示</a></li>
<li><a href="#不可避免的前端邏輯表單">不可避免的前端邏輯：表單</a></li>
</ul></li>
</ul></li>
<li><a href="#seo-優化技巧-如何設計一個高質量的-url-及頁面標題">SEO 優化技巧 ：如何設計一個高質量的 URL 及頁面標題</a><ul>
<li><a href="#搜尋引擎優化都是前端的活">搜尋引擎優化都是前端的活</a></li>
<li><a href="#如何設計一個高質量的-url">如何設計一個高質量的 URL</a><ul>
<li><a href="#受-restful-api-影響-的-url-設計">受 RESTful API 影響 的 URL 設計</a></li>
<li><a href="#手動自定義-url">手動自定義 URL</a></li>
<li><a href="#詳情頁-簡單的-url-生成規則">詳情頁 ：簡單的 URL 生成規則</a></li>
<li><a href="#自動化-url分類與多級目錄">自動化 URL：分類與多級目錄</a></li>
<li><a href="#搜尋結果頁將參數融入-url">搜尋結果頁：將參數融入 URL</a></li>
</ul></li>
<li><a href="#自動生成高質量的站點標題">自動生成高質量的站點標題</a><ul>
<li><a href="#什麼是站點標題">什麼是站點標題？</a></li>
<li><a href="#什麼才算一個高質量的站點標題">什麼才算一個高質量的站點標題？</a></li>
</ul></li>
</ul></li>
<li><a href="#你應該知道的單頁面應用的核心知識">你應該知道的單頁面應用的核心知識</a><ul>
<li><a href="#單頁面應用的演進">單頁面應用的演進</a></li>
<li><a href="#路由頁面跳轉與模組關係">路由：頁面跳轉與模組關係</a></li>
<li><a href="#資料獲取與鑑權">資料：獲取與鑑權</a></li>
<li><a href="#資料展示模板引擎">資料展示：模板引擎</a></li>
<li><a href="#互動事件與狀態管理">互動：事件與狀態管理</a><ul>
<li><a href="#元件互動狀態管理">元件互動：狀態管理</a></li>
<li><a href="#使用者互動事件">使用者互動：事件</a></li>
</ul></li>
</ul></li>
<li><a href="#客戶端儲存藝術資料儲存與模型設定">客戶端儲存藝術：資料儲存與模型設定</a><ul>
<li><a href="#模型與儲存">模型與儲存</a></li>
<li><a href="#儲存">儲存</a></li>
<li><a href="#模型的變化">模型的變化</a></li>
</ul></li>
<li><a href="#前端也需要效能優化">前端也需要效能優化</a><ul>
<li><a href="#timeline">Timeline</a></li>
<li><a href="#首屏載入優化">首屏載入優化</a></li>
<li><a href="#快取優化">快取優化</a></li>
<li><a href="#生命週期優化">生命週期優化</a></li>
<li><a href="#html5-圖片快取">HTML5 圖片快取</a></li>
<li><a href="#資源快取-api-結果">資源快取， API 結果</a></li>
</ul></li>
<li><a href="#前端移動開發">前端移動開發</a><ul>
<li><a href="#移動開發的三種類型">移動開發的三種類型</a><ul>
<li><a href="#web-應用">Web 應用</a></li>
<li><a href="#混合應用">混合應用</a></li>
<li><a href="#react-native">React Native</a></li>
</ul></li>
<li><a href="#響應式設計">響應式設計</a></li>
<li><a href="#使用者體驗">使用者體驗</a></li>
<li><a href="#效能">效能</a></li>
</ul></li>
<li><a href="#api-使用-與-設計">API 使用 與 設計 ？</a></li>
<li><a href="#前端工程化思維">前端工程化思維</a><ul>
<li><a href="#自動化構建">自動化構建</a></li>
<li><a href="#整合測試">整合測試</a></li>
</ul></li>
<li><a href="#如何以正確的姿勢從零開發一個前端應用">如何以正確的姿勢從零開發一個前端應用</a><ul>
<li><a href="#瞭解真實世界的需求">瞭解真實世界的需求</a></li>
<li><a href="#確認技術方案">確認技術方案</a></li>
<li><a href="#選擇技術棧">選擇技術棧</a></li>
<li><a href="#搭建構建系統">搭建構建系統</a></li>
<li><a href="#定義前端介面---使用-mock-server">定義前端介面 - 使用 Mock Server</a></li>
<li><a href="#實現後臺介面">實現後臺介面</a></li>
<li><a href="#對接應用編寫測試">對接應用，編寫測試</a></li>
<li><a href="#上線">上線</a></li>
</ul></li>
</ul>
</nav>
<h1 id="序為什麼前端沒有前途">序:為什麼前端沒有前途？</h1>
<p>與客戶做互動的那部分就是前端，也因此，它可以稱為客戶端。不僅僅侷限於瀏覽器前的使用者，還可以是桌面應用，混合應用。</p>
<p>處理資料的部分則是後臺</p>
<h1 id="我要成為一個前端設計師">我要成為一個前端設計師</h1>
<blockquote>
<p>我年輕的時候，是一個前端工程師。那時候，有這樣一個傳說：美工是最受妹子的歡迎，其次是半個美工的前端工程師。</p>
</blockquote>
<p>本故事純屬瞎掰，如有雷同純屬巧合——Phodal <span class="citation" data-cites="PasteRight">@PasteRight</span></p>
<p>未滿 18 年時，想成為一名 Kernel Hacker，就是那種操著鍵盤，在螢幕灑下一行行組合語言的大牛。在我學了一段時間 C++ 後，我覺得：『用記事本寫程式碼，並執行起來』的故事都是騙人的。為了將程式碼轉變為程式，你還需要一個編譯工具。</p>
<p>然而有一天，我在網咖裡看到一個人在記事本里寫程式碼。開始的時候，我覺得這個人是個新手吧，怎麼拿記事本在寫程式碼呢，不是應該都拿 IDE 才能編譯執行嗎？幾分鐘過後，我發現他居然能將，記事本寫的程式執行起來，太神奇了，Amazing Man。</p>
<p>後來，為了在別人面前裝這個 100 分的逼，我成了一名 Web 工程師，而且還是一個前端工程師。</p>
<p>（PS：以上純屬瞎扯）</p>
<h2 id="漂亮的前臺">漂亮的前臺</h2>
<p>各位看官中，有些可能不是前端工程師，那就先讓我來說說前端工程師是幹什麼。前端又可以稱之為前臺，不是那種每天對你笑、幫你開門、長得還算不錯的前臺，然而卻也差不了多少。</p>
<p>他們要做出好看的、美麗大方的介面，以免嚇走那些對顏值有要求的挑剔客戶；還要對指引好使用者，免得有些使用者認錯了樓、走錯了路口，然後再也不來光顧你們的網站了；有些時候，還要像處女座糾結於對齊，糾結於 px px 的程式設計師。</p>
<p>你還會看到他們拿起紙當尺子，一點點的測量著什麼東西，好似在懷疑這個螢幕是不是真的是 15.4 寸。 如果你看到一個程式設計師，他在糾結椅子是不是擺放正確的，那麼它有可能是三種程式設計師中的一種：處女座程式設計師、前端工程師，還有測試工程師。</p>
<p>我們就像上個世紀的網民，時不時地按下 F5 又或者 Command + R 來重新整理頁面，一直在懷疑頁面上的內容是不是最新的。好在後來，有一個偉大的大魔法師發明了一個工具，可以檢測到程式碼修改，自動地幫你重新整理頁面。終於，不再像個老大爺一樣踢電腦，以指望提高圖片的質量，甚至去掉馬賽克。</p>
<p>過去，我也無法理解：這群智力超群的程式設計師，為什麼會變得如此px px 計較，直到我成為了其中的一員。</p>
<h2 id="我要成為一個前端設計師-1">我要成為一個前端設計師</h2>
<p>習慣了大學的生活過後，我和好友楚非就一起去租了一個伺服器，從此生活就變得有點艱難。不過有了一個伺服器，我們就可以去做個網站，並託管別人的網站，然後就可以坐在學校裡數錢了。對於當時的我而言，我並不想成為一個 Web 開發工程師，我還是從心底嚮往底層的開發。</p>
<p>理想很美好，現實很殘酷。雖然我們有了一個伺服器，但是它不能立刻地為我們賺錢。我不知道一個完整的網站是怎樣的，也沒有找到客戶。後來，直到大二下學期快結束的時候，我們才算迎來真正的客戶。在那段找不到客戶，也沒有能力找客戶的日子裡，我們就這樣把自己逼上了一條不歸路。</p>
<blockquote>
<p>就這樣和很多人一樣，為了賺錢，就這樣成為了一個前端工程師。</p>
</blockquote>
<p>這時，我們就遇到了一個問題：我們倆究竟誰做前端，誰做後臺？</p>
<p>這結局大多數人都是知道的，我來負責前端。然而每每說到：他是學美術的，他去做後臺；而我是學電子資訊工程的，我來負責前端，總會有人感到一些驚訝。選擇前端，有這麼一個主要的原因：<strong>離成為設計師的目標更進一步</strong>。</p>
<p>我所理解的“設計師”，是廣泛意義上的設計師。他們做一些創意的工作，以此來創造一些令人嘖嘖稱讚的作品。這些作品不僅僅可以是一件雕塑，一幅畫，還能是一個 Idea，一段程式碼。</p>
<p><strong>當你是一個前端工程師的時候，你是一個程式設計師，還是一個設計師。</strong></p>
<p>程式設計師本身也是設計師。雖然程式已經代替了相當數量的手工操作，要想代替程式設計師則需要更多的時日。然而，程式設計師手藝的好壞是有相當大的差異的。初學程式設計的時候，總會看到各種“程式設計”這樣高大上的字眼，設計才是程式的核心。這就意味著，寫程式碼的時候，就是在設計作品。設計是一門腦力活，也是一門模式活，從中能看出一個人的風格，從而瞭解一個人的水平。</p>
<p>因為我認為，前端工程師還應該懂得設計。我便花費了很多時間去：學習素描，熟悉一些原型設計軟體，瞭解各種配色原理。以指望我可以像一個設計師一樣，做好前端網頁的設計。畢竟程式碼和大部分藝術作品一樣，容易被臨摹、複製，而要複製思想則不是一件容易的事。</p>
<p>而到了今天，我的設計能力還是有待商榷。幸運的是，我可以熟練地使用各種視覺化工具，然後做出各種美妙的圖案。</p>
<p>我還能寫編寫一行行的前端程式碼，並寫下這個系列（《我的職業是前端工程師》）的文章，來幫助大家深入瞭解前端工程師。</p>
<h2 id="關於我的職業是前端工程師">關於《我的職業是前端工程師》</h2>
<p>人啊，總是喜歡寫點東西去紀念自己的功績，我也不例外。當我寫了一段有意思的程式碼、嘗試了一個新的框架、解決了一個很久的 Bug，我總會寫個部落格來炫耀一下。後來，隨著部落格越寫越多，我開始嘗試的整理一些話題，並將其編成電子書放在 GitHub 上共享。後來，就慢慢地有了出版第一本書的機會，想來第二本書也是能出版的，也應該很快地就會出版的。</p>
<p>我的第一本書是紀念大學的專業，電子學習的是電子資訊工程，便寫了一本物聯網相關的書籍。第二本則是一本關於全棧書籍，想來我在前後端之間已經受過很多苦，也因此學了很多知識，這些知識對於我來說像是一種財富。雖然花費了相當多的時間在編寫上，但是總體上來說，對於我的益處還是大於弊處的。為了保證內容的準確性，一遍又一遍地去梳理知識體系，不得不再次去翻閱放在書架的書籍。也因此算是印證了那句話：輸出是最好的輸入。</p>
<p>前端是一個很有趣的領域，有太多的知識點，和不同的領域都有所交集。為了展示前端的廣度，只能像散文一樣展開不同的知識點。因此呢，這一系列的文章，不再像過去的電子書一樣，有著連貫的、互相依賴的知識。</p>
<p>我真正開始從事前端這個職業，算了一下也差不多是三年了。三年之前的學校三年裡，我在努力地成長為前端工程師，成為全棧工程師。而工作的這三年裡，正好是前端高速發展的三年，他的發展速度有些誇張。落後了三個月，你就有可能需要重新入門前端了，痛苦的往事。</p>
<h1 id="入門不是應該很簡單嗎">入門不是應該很簡單嗎？</h1>
<p>入門前端，是一件很難的事嗎？在今天，我也沒有想好一個答案，也不知道怎樣給出一個答案。這個問題並不取決於前端，而是取決於不同人的需求。到底是想要快得一步登天呢，還是一點點的慢慢來，去享受前端帶來的樂趣。</p>
<p>對於不同領域的學者來說，都會有一個相似的問題：如何從入門到精通？入門並不是一件很複雜的事，只是多數人想要的是<strong>更快的入門</strong>，這才是真正複雜的地方。雖說條條道路都是通過羅馬的，但並不是每條道路都是能滿足人們要求的。對於 A 說的路線並不一定適合於 A ，有可能會適合於 B；適合於 B 的路線，也有可能只適合於 B。</p>
<h2 id="前端之路">前端之路</h2>
<p>談起路線規則這事，就會聯想起演算法裡的路徑問題。想了想，發覺“如何教人入門前端”與“選擇合適的路徑”頗為相似的，要實現這樣的規劃蠻難的。先上張圖，加深一下印象：</p>
<figure>
<img src="images/short-path.jpg" alt="最短路徑" /><figcaption>最短路徑</figcaption>
</figure>
<p>接著，我們來思考這樣的一個問題：</p>
<blockquote>
<p>每個初學者都處於“1”，最後的目標都是到“9”，那麼你會怎麼幫助他們規劃路線？</p>
</blockquote>
<p>假設，每一個數字都對應了技術棧，並標註了每個技術棧學習所需要的時間。那麼，這時要計算出<strong>最快的學習路線</strong>也就容易了。而這種開掛的感覺，就像是我們擁有了遊戲中的技能樹的一樣。技能樹上，包含了所有已知的技能，以及：學習某個技能所需要的時間，學習某個技能後可以觸發某個技能等等。</p>
<figure>
<img src="images/sherlock.jpg" alt="技能樹" /><figcaption>技能樹</figcaption>
</figure>
<p>不幸的事，這個路線不可能會怎麼簡單。倘若你是一個在校的學生，或者是相似的研究人員，那麼這種路線也頗為適合。理想的情況下，我們可以自由地分配自己的時間，在對應的技術棧上花費相應的時間。這就好像是遊戲世界的技能樹一樣，我們所擁有的點數是固定的，那麼所能學習的技能也是固定的。</p>
<p>假使真實世界的前端技能樹已經很清晰，那麼這裡的點數對應的就是時間。在時間固定的情況下，我們所能學習的技能也是固定的。而技能樹中的時間花費是一個大的問題：當我們學習完某個技能後，我們可能就擁有其他技能的加成。</p>
<p>在已經學會了 ES6 的情況下，學習 TypeScript 就變得更輕鬆，這時學習 TypeScript 的時間就會更短。也因此，相似的技術棧可以歸類到一起。遺憾的是，學習相似的技術棧仍然是需要時間的。</p>
<p>回到前端技術的話題上，在編寫複雜前端應用時，我們都會採用前端框架來加快開發。前端框架的技術基礎都是一樣的，有區別的是，它們衍生出來的技術思想。有的框架創造出了一些有意思的 DSL（領域特定語言），可以藉此編寫出獨立於語言的程式碼，這些程式碼也可以用在不同的領域裡。</p>
<p>一個很有意思的例子就是 Mustache 模板，即可以讓我們用後臺語言，如 Java，來渲染 Mustache 模板為 HTML，又可以在前端裡使用 Mustache.js 來將模板渲染為 HTML。相似的，對於 React 中的 JSX 也是如此，我們即可以用 Node.js 與 React 在後臺來渲染出頁面，又可以在前端來渲染 JSX 為 HTML。</p>
<figure>
<img src="images/fe-path.png" alt="簡單的前端學習路徑" /><figcaption>簡單的前端學習路徑</figcaption>
</figure>
<h2 id="我的前端入門">我的前端入門</h2>
<p>在我剛學前端工程師的時候，由於只需要編寫 CSS、JavaScript 和 HTML，因此要做前端的活相當的簡單。有時，甚至會覺得有些乏味。</p>
<h3 id="我的第一個網站">我的第一個網站</h3>
<p>大一時，年輕氣盛就去辦了個社團，當了個社長。那會兒還能使用各種 Google 的服務，Google 剛剛開始推廣它的雲服務 Google App Engine。使用者只需要點選一個按鈕，就可以上傳程式碼，應用就會自動地部署到相應的網站上了。下圖就是我的第一個網站：</p>
<figure>
<img src="images/django_gae.jpg" alt="Django GAE" /><figcaption>Django GAE</figcaption>
</figure>
<p>當時，寫給客戶的程式碼大多乏味，沒有挑戰性。為了嘗試各種新特性，我就將各種奇怪的 CSS3 加到其中。</p>
<p>這一點在今天的日常工作裡，也沒有太多的變化。工作寫程式碼是為了活下去，業餘寫程式碼則是為了興趣。有意識地將兩者分開，才能使技術更好的成長。我們不會因為，在項目裡引入新技術而沮喪。同時，在業餘時自由的使用新的技術，來提升自己的技術與視野。</p>
<p>後來，世道變了，免費的東西還能使用，但是網站已經訪問不了。我們嘗試向 SAE 上遷移，雖然 SAE 很不錯，但是你是要去備案的。再後來，我們就去租用自己的伺服器了。</p>
<h3 id="copypaste-from-cookbook">Copy/Paste from Cookbook</h3>
<p>與現在稍有不同的是，現在寫程式碼是 Copy/Paste from StackOverflow，那時寫程式碼是 Copy/Paste from Cookbook。所以，我們只需要三本書就足夠了：</p>
<ul>
<li>CSS Cookbook</li>
<li>JavaScript Cookbook</li>
<li>jQuery Cookbook</li>
</ul>
<p>它們包含了我所需要的一切，對應於不同的功能，都有對應的程式碼。我們所需要做的就是<strong>在合適的地方放上合適的程式碼</strong>。</p>
<p>在閱讀了大量的書後，我才得到了上面的結論。不過，大學不像現在這麼“寬裕”，不能輕鬆地去買自己想看的書。一本書抵得上好幾天的飯錢，不會毫不猶豫地“一鍵下單”。現在，仍然會稍微猶豫一下，這主要是房價太貴，租的房子太小。儘管我們的學校是一所二本院校，但是圖書館還算是不小的——雖然沒有啥各種外語書，但是大部分領域的書總算是有一兩本的，每個月還會進一些新書——反正屈指可數。四年下來，我算是能知道每一本計算機書的大概位置。</p>
<p>因此，如果你只是想為了完成任務，而去完成任務。你就會發現，程式設計是相當無聊的，和一般的工作無異。</p>
<h3 id="開發工具">開發工具</h3>
<p>最初，我頗為喜歡 Adobe DreamWeaver，還有 Chrome 瀏覽器，它們結合起來能完成大部分的 UI 工作。</p>
<p>儘管在今天看來，DreamWeaver 是個一個奇怪的工具，它可以讓我們拖拽來生成程式碼，但是這些生成的程式碼都是臭不可聞的。但是我愛及了他的及時預覽地功能了，特別是當我在編寫 CSS 的時候，不再需要在瀏覽器、開發工具不斷切換。</p>
<p>慢慢地，當我開始越來越多的使用 JavaScript 時，DreamWeaver 提供的功能就變得越來越有限了，我開始覺得它越來越難用了。曾經有一段時間裡，我使用 Aptana——它可以將 minify 後的程式碼格式化。</p>
<p>現在，我使用 Intellij IDEA 和 WebStorm作為主要開發工具，它們的<strong>重構功能</strong>讓我難以自拔。當我需要修改一些簡單的文字時，我就會使用 Vim 或者 Sublime text。在命令列裡發現了一個問題，直接可用命令列來開啟並修改。</p>
<p>Chrome 瀏覽器在當時雖然很不錯，但是當時市場佔有率太低。只能拿它來作平時的瀏覽器，看看各種 IE 上的 Bug，再玩 CSS3、HTML 5 等等各種特效。多數時候你還是要用 IE 的，寫下一行行的 CSS Hack，以確保大部分的使用者是可以正常使用的。</p>
<p>今天，也仍然在使用 Chrome 作為我的日常和開發用瀏覽器。雖然它還沒有解釋臭名昭著的記憶體問題，但是我們已經離不開它的 Console，Device Toolbar 等等的功能，同時還有執行在這上面的各種外掛，如 Postman，PageSpeed 等等。</p>
<h3 id="jquery-是最好用的">jQuery 是最好用的</h3>
<p>在我發現了 jQuery 之後，我才知道它是一個神器。jQuery 有一個龐大的生態系統，有一系列豐富的外掛。我們所需要做的就是，知道我們要實現的功能，找到相應的外掛。緊接著，就去 Google 有相應的外掛，然後按照他的 README 寫下來即可。即使沒有的外掛，我們也可以很容易的編寫之。</p>
<p>到了後來，我覺得前端甚是無聊。這主要是限制於我們接的一些業務，都是企事業單位的單子，每天都是無盡的 IE 的相容問題。這讓我覺得同時使用很多個 IE 版本的 IETester，是一個偉大的軟體。</p>
<p>過了那段時間後，看到了 Node.js、Backbone、React、Angular 開啟了另外一個世界，這算是前端 3.0 的世界了。</p>
<h1 id="學習前端只需要三個月語言篇">學習前端只需要三個月【語言篇】</h1>
<blockquote>
<p>過去，我一直無法相信：一個新人在三個月裡可以學好前端。後來，我信了。因為三個月後，我又是一個前端的新人，我又需要重新入門前端。</p>
</blockquote>
<p>前端領域好似也有一個“摩爾定律”。戈登·摩爾提出來：<strong>積體電路上可容納的電晶體（電晶體）數目，約每隔24個月便會增加一倍</strong>，後來經常被引用的“18個月”。而對於前端領域來說，每隔 3-6 個月，<strong>知識點將增加一倍</strong>。</p>
<p>過去一年（即 2016 年）的每三個月（或者半年）裡，前端領域不斷湧現出新的知識，這些新的知識不斷地在更新。這些知識點，可以源自於後臺知識領域，源自於某些特定的語言，源自於新的知識理念。我們可以很輕鬆地找到一個例子，如前端所需要的 JavaScript 語言本身，這個語言出現了越來越多的變種。</p>
<p>為了完成一個複雜的前端應用，我們需要編寫大量的 JavaScript 程式碼。但是早期版本的 JavaScript，並不適合編寫中大規模的前端工程。</p>
<h2 id="javascript-語言的變化">JavaScript 語言的變化</h2>
<p>幾年間，出現了 CoffeeScript、TypeScript、ClojureScript、Dart、ES6 等等的語言，他們都可以編譯為 JavaScript，隨後就可以在瀏覽器上執行。諸如 ES6，這一個新的 JavaScript 版本（現有的 JavaScript 版本，稱為 ES5，即 EcmaScritp 5），則可以在最新的瀏覽器上執行部分或者全部的特性。</p>
<p>這些語言在不同的時間段裡，所受到的受關注程度都是不一樣的。它們都是各自的特色，在不同的時期所到的歡迎程度也是不一樣的：</p>
<figure>
<img src="images/js-language-compare.jpg" alt="JavaScript編譯語言" /><figcaption>JavaScript編譯語言</figcaption>
</figure>
<p>這種變化相當有趣。儘管 JavaScript 是所有主流瀏覽器上唯一支援的指令碼語言，但是它在過去的主要用途是用來：做一些頁面“特效”。它可以通過 DOM API 來操作頁面上的元素，而這些元素就是顯示在頁面上的內容。</p>
<p>隨後 Ajax 技術誕生了，開發人員發現可以用 JavaScript 做更多的事。JavaScript 之時，是用於在客戶端上執行一些指令。而 Ajax 則可以讓瀏覽器直接與服務端通訊。這就意味著，<strong>你可以在瀏覽器間接地去操作資料庫</strong>，前端應用便因此而變得更加龐大。</p>
<h3 id="javascript">JavaScript</h3>
<p>最初，JavaScript 是由 Netscape 僱傭 Brendan Eich 來開發的。當時他花了 10 天時間，設計出了這個語言的第一個版本。Netscape 與 Sun公司合作開發了該語言，當時 Java 語言比較火熱，也因此該語言由 LiveScript 改名為 JavaScript。由設計初衷就是，<strong>適合於新手來使用</strong>。</p>
<p>此時正值瀏覽器大戰之時，微軟也推出了與 JavaScript 相似的 JScript 語言，並且內建於 IE 3.0 中。隨後 IE 藉助於 Windows 的威力，逐漸地佔領了市場。後來，Netscape 便將 JavaScript 提交給歐洲計算機制造商協會進行標準化。標準化後的 JavaScript 便稱為 ECMAScript，JavaScript 的版本也以 ECMAScript 來命名。</p>
<p>儘管 JavaScript 的標準由 ECMA TC39<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> 委員會制定，但是要操作瀏覽器的元素，還需要 DOM（Document Object Model，文件物件模型）。而 DOM 是由 W3C 組織推薦的處理 XML 的標準程式設計介面。遺憾的是，不同瀏覽器對於 DOM 的支援並不一致，還存在一定的差異。在早期的瀏覽器裡，對於 DOM、事件、Ajax 的支援存在一定的差異，因此像 jQuery 這種跨瀏覽器的 JavaScript 庫，相當的受歡迎。</p>
<p>然而，為了新手更容易上手，該語言缺少一些關鍵的功能，如類、模組、類型等等。在一些完備的 Web 框架裡，框架本身會擁有相應的功能。</p>
<p>這些問題可以由各式各樣的 JavaScript 庫來解決。</p>
<ul>
<li>我們需要<strong>類的功能</strong>時，可以用 klass 庫來補充；</li>
<li>我們需要<strong>依賴管理</strong>時，可以用 Require.js 庫來補充；</li>
<li>我們需要<strong>類型檢查</strong>時，可以用 tcomb 庫來補充；</li>
<li>我們需要<strong>Promise 庫來解決 callback hell</strong>時，可以用 Bluebird 來補充。</li>
<li>。。。</li>
</ul>
<p>這一切看上去都很完美，但是好像有一點不對勁。</p>
<p>這些功能明明是這個語言應該要有的。我們卻要在一個又一個的項目裡，引用這些<strong>本不需要</strong>引用的庫。</p>
<h3 id="es6">ES6+</h3>
<p><strong>作為一個程式設計師，如果我們覺得一個工具不順手，那麼應該造一個新的輪子</strong>。我也喜歡去造前端的輪子，有時候是為了理解一個框架的原理，有時候則是為了建立一個更好的工具。也因此，當 JavaScript 不能滿足前端工程師需求的時候，我們應該發展出一個更好的語言。於是，ES 6 就這樣誕生了。</p>
<p>繼上面的 JavaScript 的發展歷史，現在主流瀏覽器都支援 ECMAScript 5.0 版本的標準，並且部分瀏覽器可以支援 ECMAScript 6。隨後，ECMA 的草案以年份來命名，如 2016 年釋出的 ECMAScript 草案稱之為 ECMAScript 2016。而 ES 6 則對應於 ES 2015。</p>
<p>於是，現在：</p>
<ul>
<li>你可以使用定義函數的<code>預設參數</code>。不再需要使用 option，並 merge 這個物件了。</li>
<li>你可以使用模板物件，使用形如<code>`$ {NAME}`</code>的形式來拼接模板。不再需要在一個變數切換單引號 ’ 和雙引號 “，並使用很多加號 + 。</li>
<li>你可以使用箭頭函數，來減少回撥的程式碼量，並改善作用域 this 的問題。</li>
<li>你可以使用原生的 Promises 來解決地獄式回撥的問題。</li>
<li>你還可以在 JavaScript 中使用真正的物件導向程式設計。</li>
<li>。。。</li>
</ul>
<p>在最新的 Chrome、Edge、Safari、Firefox 瀏覽器裡，它們對於 ES6 的特性支援幾乎都在 90% 以上。當我們需要在瀏覽器上執行 ES6 程式碼時，就需要使用類似於 Babel 這樣的轉譯工具，來將程式碼轉換為 ES5 來在普通瀏覽器上執行。</p>
<p>遺憾的是，主流的瀏覽器對於 ES2016+ 以及下一代的 ES.next 的支援是有限的。除此，它還有一系列需改進的語法，並不能讓我覺得滿意。</p>
<p>然後，我開始轉向了 TypeScript。</p>
<h3 id="typescript">TypeScript</h3>
<p>我開始嘗試 TypeScript 的原因是，ES6 一直在變化。在 ES6 語言特性沒有穩定下來的時候，我選擇它作為技術棧總會存在一些風險。在這個時候，TypeScript 就成為了一個更好的選擇——它建立得更早，並且語言特性穩定。而真正促使我使用 TypeScript 的契機則是，Angular 2 中採用了 TypeScript 作為開發語言。簡單的來說，就是我需要用它，所以我才學 TypeScript 的。</p>
<p>TypeScript 與其他編譯為 JavaScript 的語言初衷是類似的，為了開發大規模 JavaScript 的應用。TypeScript 是 JavaScript 的嚴格超集，任何現有的JavaScript程式都是合法的TypeScript程式。TypeScript 第一次對外發布是在 2012 年 10 月，而在那之前在微軟的內部已經開發了兩年。因此，我們可以認為它是在 2010 年左右開始開發的。</p>
<p>與同時期的 ES6 相比，它更加完善，並且更適合於大型應用開發。TypeScript 從其名字來看，就是 Type + Script，它是一個強類型的語言。而 ES6 只帶有類型檢查器，它無法保證類型是正確的。這一點在處理資料 API 時，顯得非常具有優勢。當介面發生一些變化時，這些 interface 就會告訴你哪些地方發生了變化。</p>
<p>並且未來 TypeScript 將會和 ECMAScript 建議的標準看齊。</p>
<h2 id="小結">小結</h2>
<p>除去語言本身，還有各種新的前端框架帶來的變化。和其他領域（如後臺，APP等等）中的框架一樣，有的框架可以用於開發中大型應用，有的框架則能讓我們更好地完成開發。</p>
<h1 id="如何選擇合適的前端框架告別選擇恐懼症">如何選擇合適的前端框架，告別選擇恐懼症</h1>
<blockquote>
<p>將 package.json 中的 Ionic 版本改為 2.0.0 的時候，我就思考一個問題。這個該死的問題是——我到底要用哪個框架繼續工作下去。</p>
</blockquote>
<p>剛開始學習前端的時候，SPA（單頁面應用）還沒有現在這麼流行，可以選擇的框架也很少。而今天，我隨便開啟一個技術相關的網站、應用，只需要簡單的看幾頁，就可以看到豐富的<strong>前端框架世界</strong> Angular 2、React、Vue.js、Ember.js。</p>
<p>當我還是一個新手程式設計師，我從不考慮技術選型的問題。因為不需要做技術選型、不需要更換架構的時候，便覺得框架豐富就讓它豐富吧，<strong>反正我還是用現在的技術棧</strong>。等到真正需要用的時候，依靠之前的基礎知識，我仍能很輕鬆地上手。</p>
<p>可是一旦需要考慮選型的時候，真覺得天彷彿是要塌下來一般。選擇 A 框架，則使用過 B 框架的可能會有些不滿。選用 B 框架，則使用 A 框架的人會有些不滿。選擇一個過時的框架，則大部分的人都會不滿。這點“小事”，也足夠讓你幾天幾夜睡不了一個好覺。</p>
<h2 id="前端的選擇恐懼症">前端的選擇恐懼症</h2>
<p>年輕的程式設計師都是好奇的貓，玩過一個又一個的前端框架。從毛球上弄出一條條的線，玩啊玩，最後這一個個的框架在腦子裡攪漿糊。</p>
<h3 id="技術選型不僅僅受技術影響">技術選型：不僅僅受技術影響</h3>
<p>有太多的選擇，就是一件麻煩的事；沒有選擇時，就是一件更麻煩的事；有唯一的選擇時，事情就會變得超級簡單。</p>
<p>倘若，我是那個使用 Java 來開發 API 的少年，我會使用 Spring Boot 來作為開發框架。儘管 Java 是一門臃腫的語言，但保守的選擇不會犯上大錯。</p>
<p>倘若，我是那個使用 Python 來開發 Web 應用的少年，我會使用 Django 來作為開發框架。它可以讓我快速地開發出一個應用。</p>
<p>只可惜，我不再是一個後臺開發者，我不再像過去，可以直接、沒有顧慮的選擇。當我選擇 JavaScript 時，我就犯上了「選擇恐懼症」。技術選型也是沒有銀彈的——沒有一個框架能解決所有的問題。</p>
<p>在《Growth：全棧 Web 開發思想》一書中，我曾提到過影響技術選型的幾個因素。</p>
<figure>
<img src="images/tech-decide.png" alt="技術選擇因素" /><figcaption>技術選擇因素</figcaption>
</figure>
<p>這時，為了更好的考量不同的因素，你就需要列出重要的象限，如<strong>開發效率</strong>、團隊喜好等等。並依此來決定，哪個框架更適合當前的團隊和項目。</p>
<figure>
<img src="images/pri.jpg" alt="PRI" /><figcaption>PRI</figcaption>
</figure>
<p>即使，不考慮前端框架以外的因素，那麼技術選型也是相當痛苦的一件事。</p>
<h3 id="上線時間影響框架">上線時間影響框架</h3>
<p>每一個框架從誕生到受歡迎，都有其特定的原因和背景。不同的開發者選擇時，也是依據於其特定情景下的原因和背景。</p>
<p>如 Ruby On Rails誕生之時，帶來了極大的開發效率，而開發效率正是當時大部分人的痛點。我們知道 Ruby On Rails 是一個大而廣的框架，它可以提供開發者所需要的一切，開發者所需要做的就是實現業務程式碼。當開發效率不再是問題時，自由度變成了一些開發者的痛點，此時像 Sinatra 這樣的微框架就受這些人歡迎。</p>
<p>也因此，開發效率會在很大程度上影響技術選型。畢竟，開發效率在很大程度上決定了上線時間，上線時間很大地影響了技術選型。</p>
<ul>
<li>用幾星期的時間來做一個網站，我首先想到的會是找一個模板。</li>
<li>用幾個月的時候來做一個網站，我仍然會想到找一個框架。</li>
<li>用幾個年的時間來做一個網站，我會想著是不是可以造幾個輪子。</li>
</ul>
<p>遺憾的是，要遇到可以造輪子的項目不多。</p>
<h3 id="錘子定律你需要更大的視野">錘子定律：你需要更大的視野</h3>
<p><strong>年輕的時候，學會了 A 框架，總覺得 Z 網站用 A 框架來實現會更好</strong>，一定不會像今天這樣經常崩潰、出Bug。**時間一長，有時候就會發現，Z 網站使用 A 不合適，他們的問題並不是框架的問題，而是運維的問題。</p>
<p>後來，出於對職業發展的探索，我開始瞭解諮詢師，看到一本名為《諮詢的奧祕》的書籍。在這其中，提到一個有意思的定律“錘子定律”（又稱為工具定律）——<strong>聖誕節收到一把錘子的孩子，會發現所有東西都需要敲打</strong>。 出現這種情況的主要原因是，<strong>開發者對一個熟悉的工具過度的依賴</strong>。</p>
<p>認真觀察，就會發現這個現象隨處可見。當一個新手程式設計師學會了某個最新的框架，通常來說這個框架有著更多的優點，這個時候最容易出現的想法是：<strong>替換現有的框架</strong>。可是，現有的框架並沒有什麼大的問題。並且憑估不充分時，新的框架則存在更多的風險。</p>
<p>並且，對於某個熟悉工具的過度依賴，特別容易影響到技術決策——看不到更多的可能性。這時候，我們就需要頭腦風暴。但是這種情況下，頭腦風暴很難幫助解決問題。</p>
<p>在這個時候，擁有更多項目、框架經驗的人，可能會做出更好的選擇。</p>
<h2 id="前端框架一覽">前端框架一覽</h2>
<p>在這個複雜的前端框架世界裡，我不敢自稱是有豐富的徒刑經驗。我只能去分享我用過的那些框架，讀者們再結合其他不同的框架來做決定。</p>
<h3 id="jquery-使用生態解決問題">jQuery, 使用生態解決問題</h3>
<p>jQuery 創立之初的主要目標是，簡化 HTML 與 JavaScript 之間的操作，開發者可以輕鬆地使用 <code>$('elment').doSomething()</code> 的形式來對元素進行操作。誕生之後，由於其簡單容易手、並且擁有豐富的外掛，幾度成為最受歡迎的前端框架。大部分動態互動效果，都能輕鬆地找到 jQuery 外掛。即使，沒有也能通過其 API，快速地編寫相應的外掛。</p>
<p>在很多人看來，jQuery 似乎是一個不會在未來用到的框架。可惜到了今天（2017年），我仍然還在項目中使用 jQuery 框架。一年前，我們仍在一個流量巨大的搜尋網站上使用用 jQuery。在這幾個項目上，仍然使用 jQuery 的原因，大抵有：</p>
<ul>
<li>項目功能比較簡單。並不需要做成一個<strong>單頁面應用</strong>，就不需要 MV* 框架</li>
<li>項目是一個<strong>遺留系統</strong>。與其使用其他框架來替換，不如留著以後重寫項目</li>
</ul>
<p>所以，在網際網路上仍有大量的網站在使用 jQuery。這些網站多數是 CMS（內容管理系統）、學校網站、政府機構的網站等等。對於這些以內容為主的網站來說，他們並不需要更好的使用者體驗，只需要能正確的顯示內容即可。</p>
<p>因此即使在今天，對於一般的 Web 應用來說，JavaScript 搭配 jQuery 生態下的外掛就夠用。然而，對於一些為使用者提供服務的網站來說，前端就不是那麼簡單。</p>
<h3 id="backbone.js脊椎連線框架">Backbone.js，脊椎連線框架</h3>
<p>從 Ajax 出現的那時候開始，前端便迎來了一個新的天地。後來，智慧手機開始流行開來。Web 便從桌面端往移動端發展，越來越多的公司開始製作移動應用（APP 和 移動網站）。jQuery Mobile 也誕生這個特殊的時候，然而開發起中大型應用就有些吃力。隨後就誕生了 Backbone、Angular 等等的一系列框架。</p>
<p>畢竟，<strong>作為一個程式設計師，如果我們覺得一個工具不順手，那麼應該造一個新的輪子。</strong></p>
<p>Backbone.js 是一個輕量級的前端框架，其程式設計範型大致上匹配MVC架構。它為應用程式提供了模型(models)、集合(collections)、檢視(views)的結構。</p>
<p>Backbone 的神奇之處在於，在可以結合不同的框架在一起使用。就像脊椎一樣，連線上身體的各個部分。使用 Require.js 來管理依賴；使用 jQuery 來管理 DOM；使用 Mustache 來作為模板。它可以和當時流行的框架，很好地結合到一起。在今天看來，能結合其他前端框架，是一件非常難得的事。</p>
<p>遺憾的是，Backbone.js 有一些的缺陷，使它無法滿足複雜的前端應用，如 Model 模型比較簡單，要處理好 View 比較複雜。除此，還有更新 DOM 帶來的效能問題。</p>
<h3 id="angular一站式提高生產力">Angular，一站式提高生產力</h3>
<p>與 Backbone 同一時代誕生的 Angular 便是一個大而全的 MVC 框架。在這個框架裡，它提供了我們所需要的各種功能，如模組管理、雙向繫結等等。它涵蓋了開發中的各個層面，並且層與層之間都經過了精心調適。</p>
<p>我們所需要做的便是遵循其設計思想，來一步步完善我們的應用。Angular.js 的建立理念是：即聲明式程式設計應該用於構建使用者介面以及編寫軟體構件，而指令式程式設計非常適合來表示業務邏輯。</p>
<p>我開始使用 Angular.js 的原因是，我使用 Ionic 來建立混合應用。出於對製作移動應用的好奇，我建立了一個又一個的移動應用，也在這時學會了 Angular.js。對於我而言，選擇合適的技術棧，遠遠比選擇流行的技術棧要重要得多，這也是我喜歡使用 Ionic 的原因。當我們在製作一個應用，它對效能要求不是很高的時候，那麼我們應該選擇開發速度更快的技術棧。</p>
<p>對於複雜的前端應用來說，基於 Angular.js 應用的執行效率，仍然有大量地改進空間。在應用執行的過程中，需要不斷地操作 DOM，會造成明顯的卡頓。對於 WebView 效能較差或早期的移動裝置來說，這就是一個致命傷。</p>
<p>幸運的是在 2016 年底，Angular 團隊推出了 Angular 2，它使用 Zone.js 實現變化的自動檢測、</p>
<p>而遲來的 Angular 2 則受<strong>奧斯本效應</strong><a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>的影響，逼得相當多的開發者們開始轉向其它的框架。</p>
<h3 id="react元件化提高複用">React，元件化提高複用</h3>
<p>從 Backbone 和 Angular.js 的效能問題上來看，我們會發現 DOM 是單頁面應用急需改善的問題——主要是DOM 的操作非常慢。而在單頁面應用中，我們又需要處理大量的 DOM，效能就更是問題了。於是，採用 Virtual DOM 的 React 的誕生，讓那些飽受效能苦惱的開發者歡迎。</p>
<p>傳統的 DOM 操作是直接在 DOM 上操作的，當需要修改一系列元素中的值時，就會直接對 DOM 進行操作。而採用 Virtual DOM 則會對需要修改的 DOM 進行比較（DIFF），從而只選擇需要修改的部分。也因此對於不需要大量修改 DOM 的應用來說，採用 Virtual DOM 並不會有優勢。開發者就可以建立出可互動的 UI。</p>
<p>除了編寫應用時，不需要對 DOM 進行直接操作，提高了應用的效能。React 還有一個重要思想是元件化，即 UI 中的每個元件都是獨立封裝的。與此同時，由於這些元件獨立於 HTML，使它們不僅僅可以執行在瀏覽器裡，還能作為原生應用的元件來執行。</p>
<p>同時，在 React 中還引入了 JSX 模板，即在 JS 中編寫模板，還需要使用 ES 6。令人遺憾的是 React 只是一個 View 層，它是為了優化 DOM 的操作而誕生的。為了完成一個完整的應用，我們還需要路由庫、執行單向流庫、web API 呼叫庫、測試庫、依賴管理庫等等，這簡直是一場噩夢。因此為了完整搭建出一個完整的 React 項目，我們還需要做大量的額外工作。</p>
<p>大量的人選擇 React 還有一個原因是：React Native、React VR 等等，可以讓 React 執行在不同的平臺之上。我們還能通過 React 輕鬆編寫出原生應用，還有 VR 應用。</p>
<p>在看到 Angular 2 升級以及 React 複雜性的時候，我相信有相當多的開發者轉而選擇 Vue.js。</p>
<h3 id="vue.js簡單也是提高效率">Vue.js，簡單也是提高效率</h3>
<p>引自官網的介紹，Vue.js 是一套構建使用者介面的漸進式框架，專注於MVVM 模型的 ViewModel 層。Vue.js 不僅簡單、容易上手、配置設施齊全，同時擁有中文文件。</p>
<p>對於使用 Vue.js 的開發者來說，我們仍然可以使用 熟悉的 HTML 和 CSS 來編寫程式碼。並且，Vue.js 也使用了 Virtual DOM、Reactive 及元件化的思想，可以讓我們集中精力於編寫應用，而不是應用的效能。</p>
<p>對於沒有 Angular 和 React 經驗的團隊，並且規模不大的前端項目來說，Vue.js 是一個非常好的選擇。</p>
<p>雖然 Vue.js 的生態與 React 相比雖然差上一截，但是配套設施還是相當齊全的，如 Vuex 、 VueRouter。只是，這些元件配套都由官方來提供、維護，甚至連 awesome-vue 也都是官方項目，總覺得有些奇怪。</p>
<p>除此，Vue.js 中定義了相當多的規矩，這種風格似乎由 jQuery 時代遺留下來的。照著這些規矩來寫程式碼，讓人覺得有些不自在。</p>
<p>和 React 相似的是，Vue.js 也有相應的 Native 方案 Weex，仍然值得我們期待。</p>
<h3 id="小結-1">小結</h3>
<p>除了上面提到的這些前端框架，我還用過 Reactive、Ember.js、Mithril.js，遺憾的是同 Vue.js 一樣，我沒有在大一點的、正式項目上用過。也因此，我沒有能力、經驗、精力去做更詳細的介紹。有興趣的讀者，可以做更詳細的瞭解，也可以在 GitHub (<a href="https://github.com/phodal/fe" class="uri">https://github.com/phodal/fe</a>) 上給我們提交一個 Pull Request。</p>
<h2 id="總結">總結</h2>
<p>今天，大部分的框架並不只是那麼簡單。為了使用這個框架你，可能需要學習更多的框架、知識、理論。一個很好的例子就是 React，這個框架的開發人員，引入了相當多的概念，JSX、VIrtual Dom。而為了更好地使用 React 來開發，我們還需要引入其他框架，如 Redux、ES6 等等的內容。</p>
<p>這些框架從思想上存在一些差異，但是它們都有相似之處，如元件化、MV**、All in JS、模板引擎等等。欲知後事如何，請期待下一章“前端=模板 + 資料，這就是模板引擎”。</p>
<h1 id="前端工程師必會的六個偵錯技能">前端工程師必會的六個偵錯技能</h1>
<blockquote>
<p>我還是一個野生程式設計師的時候，不會 Debug，只會傻傻地寫一句句 std::count。即使是在今天，有些時候我也會這樣做：打一個 console.log，然後看看結果是不是和預期的一樣。如果不是和預期一樣，就修改一下程式碼，重新整理一下瀏覽器。這得虧是 JavaScript 是一門動態語言，可以很快的看到執行的結果。</p>
</blockquote>
<p><strong>前言</strong>： 本章裡，主要介紹如何偵錯前端應用——基本的偵錯： HTML、CSS 和 JavaScript；使用網路工具對 API 進行測試；對移動裝置進行偵錯：使用瀏覽器的模擬器、真機、iOS 模擬；對網站的效能進行偵錯等內容。</p>
<p>偵錯（Debug）在<a href="https://zh.wikipedia.org/wiki/%E8%B0%83%E8%AF%95">維基百科</a>上的定義是：是發現和減少計算機程式或電子儀器裝置中程式錯誤的一個過程。</p>
<p>多數時候，偵錯是為了找到程式碼中的錯誤，並具體定位到錯誤的地方。幸運的是，現在的前端框架都比較人性化了，可以和大部分的後臺框架一樣，提示程式碼中出錯的地方。這時，我們只需要藉助於瀏覽器的偵錯，找到錯誤的行數，並檢視錯誤的原因。</p>
<p>有些時候，我們偵錯是為下一步程式設計，提供一些理論依據。如在應用執行的時候，我們可以使用瀏覽器打個斷點，並在 Console 中輸入程式碼偵錯下一步要做的事。最後，再將這些程式碼複製到 IDE 或者編輯器上即可。</p>
<h2 id="我的偵錯入門">我的偵錯入門</h2>
<p>與我的程式設計經驗相比，我學會 Debug 的時間比較晚。我是在大學裡學會 Debug 的，當時在為一個支援線上偵錯的晶片寫程式。對於嵌入式開發而言，不同的晶片都會有不同的 IDE。有的 IDE 可以支援偵錯，有的則不行；有的 IDE 則連基本的語法高亮都沒有。</p>
<p>對於支援線上偵錯的開發環境來說，我們只需要打一兩個斷點，看程式是否執行到這個邏輯，又或者是按下“下一步”按鈕，看程式執行到哪些地方，並實時的預覽變數的值。</p>
<p>對於不支援線上偵錯的晶片來說，沒有螢幕也就不能使用 printf 來輸出結果。只能通過 SD 卡里的檔案系統來寫入日記，再計算機上讀取日記來分析。這隻的是一件麻煩的事，對於沒有 SD 卡的開發板來說，還需要騰出幾個指令碼接上 SD 卡。也有些晶片是不能使用 SD 卡的，這時我們就只能依靠於想象力來偵錯。</p>
<p>在今天開發 Web 應用時，上述的內容都只是基本的偵錯。有一些能支援更高階的偵錯——如評估表示式，即利用當前的變數值，來實時計算，並慢慢完成下一步的程式碼。最初，我是在用 Intellij Idea 寫程式的時候，學會在後臺程式設計時使用 <code>evaluate expression</code>。它可以在排程程式碼的時候，我們可以邊實現功能。</p>
<p>後來，我才醒悟到在前端領域，這是基本的偵錯功能，在 Chrome、Safari 這些現代的瀏覽器上都能這樣做。</p>
<p>與一般的單機應用相比，讓 Web 應用不能如期執行有更多的原因。並且相當多的原因與程式碼無關，如：</p>
<ul>
<li>服務在執行中崩潰，沒有向前端返回資料，前端只能使用超時來處理。這時，我們可以通過瀏覽器中的 Network 來知道這件事。</li>
<li>本地開發的時候，URL 的編碼都是沒有問題的，而線上上則出了問題。經過一系列復現和排察後，才發現問題出在 Nginx 上的轉義上。</li>
<li>等等</li>
</ul>
<p>這時，我們就需要使用更好的工具來幫助開發。</p>
<h2 id="基本偵錯技巧實時偵錯">基本偵錯技巧：實時偵錯</h2>
<p>開始之前，我們需要開啟 Chrome 瀏覽器的偵錯視窗。除了點滑鼠右鍵，然後選擇“審查元素”之外，還可以：</p>
<ul>
<li>Windows / Linux 作業系統，使用 Ctrl + Shift + I 快捷鍵開啟開發人員工具</li>
<li>Mac OS 作業系統，使用 Comand + Option + I 快捷鍵開啟開發人員工具</li>
</ul>
<p>這個偵錯視窗看上去，有點高大上：</p>
<figure>
<img src="images/basic-inspect.png" alt="認識一下偵錯視窗" /><figcaption>認識一下偵錯視窗</figcaption>
</figure>
<p>圖中左上角的兩個圖示，分別是：</p>
<ul>
<li><strong>審查元素</strong>。可以讓我們檢查頁面上的 DOM 元素，瞭解 DOM 結構</li>
<li><strong>裝置工具欄開關</strong>。在裝置工具欄裡，可以模擬不同的移動裝置螢幕、網路狀態等等的內容。</li>
</ul>
<p>隨後就是各類工具了，讓我們在隨後的內容裡慢慢欣賞。而在平時的工作中，前端工程師用得最多的就是偵錯樣式和程式碼了，這些也是作為一個前端程式設計師必須要掌握的。</p>
<h3 id="實時偵錯樣式">實時偵錯樣式</h3>
<p>作為一個有經驗的前端程式設計師，當我們開發前端介面時，都會：</p>
<ol type="1">
<li>在瀏覽器上編寫 CSS 和 HTML</li>
<li>將編寫好的 CSS 和 HTML 複製到程式碼中</li>
<li>重新載入頁面，看修改完的頁面是否正確</li>
<li>如果不正確，重複 1~3</li>
</ol>
<p>而當我們想檢視頁面上某個元素的 DOM 結構或者 CSS 時，我們可以點選開發者工具中的 Inspect 圖示，並在頁面上選擇相應的元素。我們還可以使用快捷鍵來選擇元素，Windows / Linux上使用 Shift + Ctrl + C，Mac OS 上使用 Command + Shift + C。如下圖所示：</p>
<figure>
<img src="images/inspect-styles.jpg" alt="實時偵錯樣式" /><figcaption>實時偵錯樣式</figcaption>
</figure>
<p>我們還會發現工具欄中的 Elements 選單自動被選上了，這是因為我們要選擇的元素是屬於 Elements 下的。也因此，還可以在 Elements 中選擇 HTML程式碼，檢視它在頁面上的位置。它們兩者是互相對應的，當我們選擇一個元素時，會自動為我們選擇相應的元素。</p>
<p>編碼時，可以在左側的“元素區”編輯 HTML，右側的區域的“Styles”可以檢視元素的樣式，“Computed”可以檢視元素的拿模型，“Event Listeners”則可以檢視元素的監聽事件，等等的內容。由於 CSS 樣式存在一定的優化級，如：</p>
<ul>
<li>元素選擇器選擇越精確，優化級越高</li>
<li>相同類型選擇器制定的樣式，越靠後的優先順序越高</li>
</ul>
<p>因而在複雜的前端項目裡，我們看到右側的樣式區域特別複雜，一層巢狀一層，如上圖中的右側區域。有些時候，是因為我們想共用一些樣式；有些時候，是因為在修改時，我們擔心影響其他區域，而使用更精確的選擇器。不幸的是，在一些早期的程式碼裡，我們還會看到在很多的地方里寫了<code>!important</code>這樣的程式碼。</p>
<h3 id="實時偵錯程式碼">實時偵錯程式碼</h3>
<p>與靜態語言相比，JavaScript的偵錯就相對比較簡單一些，我們可以在執行的時候偵錯程式碼。只需要在瀏覽器的相就部分打個斷點，再執行相應的操作，就可以等程式碼掉到這個坑裡。如下是 Chrome 瀏覽器進行程式碼偵錯時的截圖：</p>
<figure>
<img src="images/realtime-debug.png" alt="Chrome 偵錯" /><figcaption>Chrome 偵錯</figcaption>
</figure>
<p>從工具欄中的 Sources 就可以進行到這個介面。左側的部分會顯示當前頁面的程式碼及資源，如 HTML、CSS、JavaScript，還有圖片等。這些內容都是由當前頁面的 html 載入來決定的，如果是單頁面應用，則會是所有的資源。</p>
<p>如上圖所示，偵錯時，我們只需要：</p>
<ul>
<li>選擇相應的源碼檔案</li>
<li>在中間區域在相應的行數上打上斷點</li>
<li>再重新整理頁面就可以進入偵錯</li>
</ul>
<p>這時，我們只需要將游標，移動到正在偵錯的變數上，就可以實時預覽這個值。我們還能在 Console 裡對這些值進行實時的處理，當業務邏輯比較複雜時，這個功能就特別有幫助——實時的編寫程式碼。</p>
<h2 id="移動裝置偵錯">移動裝置偵錯</h2>
<p>從幾年前開始，越來越多的公司將 Mobile First 作為第一優先順序的技術轉型。這時對於前端而言，我們需要響應式設計，我們需要處理不同的解析度，我們需要處理不同的作業系統，我們需要編寫更多的程式碼，以及見證更多的 Bug 誕生。</p>
<p>越來越多的移動端功能需要開發時，能提供好的開發體驗的工具就會越受歡迎，於是各個瀏覽器產商就提供了更好的移動開發功能：</p>
<ul>
<li>可以在瀏覽器上模擬真機的解析度、User Agent 等等基本的資訊</li>
<li>提供介面來連線真機，並允許開發者在上面進行偵錯。</li>
</ul>
<p>在瀏覽器上模擬的特點是，我們可以一次開發匹配多種解析度的裝置，但是並不能發現一些真機才存在的 Bug——如 Android 裝置的後退鍵。而真機的缺點則是，需要一個個裝置的進行偵錯。因此，理想的開發模式是：<strong>先在瀏覽器進行響應式設計，隨後在真機上進行測試</strong>。</p>
<h3 id="模擬真機裝置模擬器">模擬真機：裝置模擬器</h3>
<p>為了適配不同分配率的移動裝置時，我們會使用 media query 進行響應式設計。並制定出一些螢幕的解析度，並以此來區分三種類型的裝置：計算機、平板、手機，如針對於計算機的畫素應該是大於 1024 的。</p>
<p>螢幕大小隻是用來判斷的一部分依據，還有一部分是通過 User Agent。它包含客戶端瀏覽器的相關資訊，如所使用的作業系統及版本、CPU 類型、瀏覽器及版本、瀏覽器渲染引擎等等。如下是我使用瀏覽器時，瀏覽器發出的 User Agent：</p>
<p><code>Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Mobile Safari/537.36</code></p>
<p>那麼，我們就可以根據這些資訊，最終確定裝置是桌面裝置，還是移動裝置，是 Android 手機，還是 iOS 手機。</p>
<p>我們所需要的就是，開啟開發者工具，然後選擇圖示中的裝置工具欄，就有如下的圖：</p>
<figure>
<img src="images/chrome-mobile.jpg" alt="Chrome 移動裝置" /><figcaption>Chrome 移動裝置</figcaption>
</figure>
<p>在使用它進行偵錯時，我們可以自定義螢幕大小，也可以選擇一些主流的裝置進行響應式設計，如iPhone。除此，我們還能測試不同的網路環境，如 4G、2G 的下載速度，又或者是離線情況下使用。</p>
<p>如果我們只是適配不同的裝置螢幕，那麼我們使用這個工具就夠了。而當我們需要做一些裝置相關的邏輯時，我們還需要使用真機來進行偵錯。</p>
<h3 id="真機偵錯device-inspect">真機偵錯：Device Inspect</h3>
<p>過去的很長一段時間裡，我一直都不需要真機偵錯這種功能——因為只是進行響應式設計。當我們在項目上遇到一系列關於 Android 返回鍵的 Bug 時，我們就不得不使用裝置進行偵錯。</p>
<p>對於移動單頁面應用來說，我們需要建立一系列的 UI、事件和行為。理論上，我們需要保證使用者可以在全屏的情況下，像一個移動應用一樣執行。除了一般應用的功能，我們還需要在頁面上建立返回鍵來返回到上一個頁面。這時，難免的我們就需要處理 Android 裝置上的這種 Bug。於是，我們需要：</p>
<ul>
<li>判斷裝置是不是 Android 裝置</li>
<li>判斷按下的是裝置上的返回鍵，而不是瀏覽器上的返回</li>
<li>如果是裝置上的返回鍵，則進行特殊處理，避免使用者退出應用</li>
</ul>
<p>這時我們就需要連線上真機，並在瀏覽器上開啟 <code>chrome://inspect/</code>，進入移動裝置的偵錯介面，並在手機 Chrome 瀏覽器上敲入要偵錯的網址：</p>
<p><a href="https://phodal.github.io/motree/" class="uri">https://phodal.github.io/motree/</a></p>
<figure>
<img src="images/inspect-devices.jpg" alt="Inspect Devices" /><figcaption>Inspect Devices</figcaption>
</figure>
<p>隨後，我們就可以像在桌面瀏覽器的偵錯一樣，對程式碼進行偵錯。</p>
<p>同理，對於 Safari 瀏覽器來說也是類似的。除此，Safari 瀏覽器可以支援更有意思的偵錯，如果正在開發的應用是混合應用，Safari 也可以對此進行偵錯。開發混合應用時，我們往往會遇到一些奇怪的 Bug，這時我們就需要它了。</p>
<figure>
<img src="images/safari-hybird.jpg" alt="Safari Simulator" /><figcaption>Safari Simulator</figcaption>
</figure>
<h2 id="網路偵錯">網路偵錯</h2>
<p>在前後端 Web 應用開發的初期，前後端進行互動是一種痛苦的事，會遇到各種意味之外的錯誤。我們需要檢視參數傳遞過程中是否漏傳了，是否傳入了一些錯誤的值，是否是跨域問題等等。</p>
<h3 id="網路偵錯-1">網路偵錯</h3>
<p>Chrome 裡的開發者工具中的 Network 不僅可以檢視頁面的加速速度，還可以看我們發出的請求的詳細資訊、返回結果的詳細資訊，以及我們傳送給服務端的資料。如下圖所示：</p>
<figure>
<img src="images/debug-network.jpg" alt="Debug網路" /><figcaption>Debug網路</figcaption>
</figure>
<p>在圖裡，我們可以清晰地看到請求的 URL、返回的狀態碼，它可以讓我們知道發出的請求是對的、返回的狀態也是對的。如果我們發出的請求是對的，而返回的內容是錯的，那麼我們可以相信這是服務端的錯誤。如果返回的狀態碼是錯的，我們也可以看出到底是服務端的錯誤，還是客戶端的錯誤。</p>
<p>設計表單時，我們可以看到它發出的參數是否是正確的。</p>
<figure>
<img src="images/form-data.png" alt="表單資料" /><figcaption>表單資料</figcaption>
</figure>
<p>這一來一往，我們就知道到底是哪個地方的問題。</p>
<h3 id="使用外掛">使用外掛</h3>
<p>除了上面說到的工具，我們還可以在 Chrome 應用商店裡找到更多、更合適的工具。我在我的 GitHub 上維護了，我常用的一些工具：<a href="https://github.com/phodal/toolbox" class="uri">https://github.com/phodal/toolbox</a>，我整理了平時使用的外掛在上面。</p>
<p>讓我推薦兩個簡單的工具，一個是 Postman，用於偵錯 API 用的：</p>
<figure>
<img src="images/postman.png" alt="Postman" /><figcaption>Postman</figcaption>
</figure>
<p>還有一個是 Google 的 Page Speed，可以幫助我們優化網路：</p>
<figure>
<img src="images/pagespeed-reseult.png" alt="PageSpeed 結果" /><figcaption>PageSpeed 結果</figcaption>
</figure>
<h2 id="小結-2">小結</h2>
<p>在這一章裡介紹了使用 Chrome 瀏覽器來偵錯的工具，這些在前端工程師的日常開發中非常有用。</p>
<p>除此，在 Chrome 瀏覽器裡還有一些額外的功能可以使用。如在 “Application”選單欄中，我們可以看到與應用相關的一些快取和儲存資訊。Chrome 瀏覽器裡，我們可以看到 Local Storage、Cookies、Session Storage、IndexedDB、Web SQL 等等的用於資料儲存的工具。編寫單頁面應用時，我們都需要在客戶端儲存一些資料，這時就需要用到這個工具。除此，還有 Google PWA 應用的一些相關屬性，Manifest、Service Workers。</p>
<h1 id="如何以正確的姿勢練習深化前端知識">如何以正確的姿勢練習，深化前端知識</h1>
<blockquote>
<p>要成為一個優秀的前端工程師，需要什麼技能和學習？答案：練習</p>
</blockquote>
<p>在逛知乎、SegmentFault 又或者是相似的技術社羣，我們總會看到類似的問題。新手總會關注於，需要怎樣的技能，怎麼才能入門？有一點經驗的程式設計師則是，需要練習什麼？如若一個程式設計師已經懂得問題的關鍵是，程式設計需要大量的練習。那麼，我想這個程式設計師已經入了這個行道了。</p>
<p>在我成為所謂的『前端工程師』之前，我沒有想到會變成這樣的結果。</p>
<h2 id="前端項目的練習過程">前端項目的練習過程</h2>
<p>年少的時候，想要做的是 Kernel Hacker。大學時，我做點前端相關的兼職，順便賺錢點錢。再用這點錢，買點硬體做一些底層、低階的程式設計，帶著去實驗室，拿著電洛鐵，高喊著：讓我們來做一個毀滅世界的機器人。好在，後來我離這個行當有點遠，要不這個世界可能就岌岌可危了。反而因此倒是，學會了相當多的前端知識，以及在今天看來是屠龍之術的 IE 相容。</p>
<p>隨後，在研究資料視覺化時，我看著用 JavaScript、HTML、CSS 可以做出這麼炫的效果。我就繼續回到圖形程式設計這個行當，前端的圖形程式設計倒也簡單，只需要找一個庫，多加練習就可以了。練習多了，便發現，需要更多的<strong>物件導向程式設計</strong>經驗，要不寫出來的程式碼就跟屎一樣。要是在今天，那可能就是<strong>函數語言程式設計</strong>經驗了。</p>
<p>玩了那麼多的東西后，我便就對這些東西駕輕就熟了。而在今天看來，仍然走了相當多的彎路。當有人再問我『怎樣練習才能成為一個優秀的前端工程師』時，我便想著：我應該好好的回答一下這個問題。</p>
<h3 id="output-is-input">Output is Input</h3>
<p>我一直很喜歡那句，Output is Input 的話，即：</p>
<figure>
<img src="images/output-input.png" alt="Output is input" /><figcaption>Output is input</figcaption>
</figure>
<p>即，我們輸出知識的時候，便是在輸入更完整的知識。因此當我練習的時候，我便會刻意地去結合使用他們，往往能達到事半功倍的效果。想嘗試玩一個新的框架時，我便會用這樣的邏輯去玩它：<strong>使用新框架編寫一個應用，再閱讀、整理相應的資料</strong>。</p>
<p>你若問我，為什麼我會這麼練習？我想那大概是，我可以<strong>更早的得到反饋</strong>。我可以更早的知道，A 框架對於使用過 B 框架的人來說有些難度，我也能輕鬆地指出他們的差異。甚至，如果這是一個新的項目，那麼我還能用一種『不很完美的姿勢』完成之。而如果只是完成這個項目，那對於我而言也沒有多少 實質性的提高。</p>
<p>遺憾的是對於多數人來說，可能就只是完成項目這一程度，後面仍然還有好長的路要走。做一個好的前端工程師，即要做很多的項目，又要讀一些書。即要會使用這個框架，又要知道他的一些基本的思想。</p>
<p>習慣了先輸出、後輸入的過程後，練習起來就很輕鬆了。</p>
<h3 id="練習框架技術的時機">練習框架、技術的時機</h3>
<p>練習，那可是相當燒時間的大事；時間，又是一種相寶貴的資源。暫不說，相當於好幾年的十萬小時理論。對於我們這些每天要早出晚歸的工作族來說，八小時以外的時間就更小了。對於一個在校的計算機專業學生來說，也不一定能在四年裡搞定。</p>
<p>而這時候如果又選擇了一個錯誤的技術棧，哪怕是相當的浪費時間了。好在我們已經在那篇《<a href="https://read.douban.com/reader/column/5945187/chapter/30511309">學習前端只需要三個月【框架篇】</a>》中討論瞭如何選擇一個合適的技術棧。此時還有一個問題是，如何在一個合適的時機練習它。</p>
<p>過去，習慣了將一些 Idea 放在 <a href="https://github.com/phodal/ideas/issues">GitHub</a> 上變成一個清單。也因此習慣了，將一些想要玩的框架放到了 TODO Lists 中，再慢慢地享受將他們完結的愉悅感。</p>
<p>當有一個新的框架出現時，看看知乎、微博、微信群裡的討論還不錯，我就會將這個框架加到 Todo Lists。在一個週末，或者中午，搭建一下項目，玩一下 DEMO。</p>
<p>隨後，這個框架就會進入評估期。評估一個框架可不是一件容易的事，要從不同的角度去了解它：社羣歡迎程度、API 變化程度、Roadmap 計劃、Release 情況等等。再確認一下框架是否可以適合當前的項目，可以的話，就會建立一個新的分支來玩玩，又或者直接引入項目。</p>
<p>如果這是一個有前景的框架，那麼我就會選擇一個合適的時機（有時間），建立一個開源來應用它。每個人都會有一些偏愛，這也決定了他們可能不會去玩某些框架，這倒是有些可惜了。</p>
<p>當我們決定去練習的時候，我們更需要一些練習的技巧。</p>
<h2 id="練習的過程">練習的過程</h2>
<h2 id="練習框架技術的技巧">練習框架、技術的技巧</h2>
<p>練習嘛，我想就這麼幾步：</p>
<ul>
<li>找到一個模板</li>
<li>邊修改模板，邊查閱資料，以此來完成一個應用</li>
<li>閱讀官方文件或者程式碼來補漏</li>
<li>編寫部落格、文章、書籍來加強印象</li>
</ul>
<p>我喜歡的就是這種輸入和輸出相結合的形式。一開始的時候，就應該先做一個應用。這種用意特別明顯，藉此可以快速地瞭解一個框架，就會覺得相當有成就感。隨後就是去補缺補漏，以便於我們可以更好地完成應用。最後，當我們寫文章去總結的時候，便會對這個框架有更基礎的認識——像擁有一張清晰的思維導圖，熟悉他的方方面面。</p>
<h3 id="使用模板">使用模板</h3>
<p>對於多數的人而言，也包括我，決定去使用一個框架的時候，表明它已經是一個幾近成熟的框架——我們可以很容易找到一些資料。依據現在框架的發展趨勢，大部分的框架都會提供一個腳手架，即應用程式模擬。只需要執行這個模板，我們就可以有一個 hello,world。</p>
<p>如 Angular 官方提供了一個 <a href="https://github.com/angular/angular-seed">angular-seed</a> 的項目，它提供了一套基本的模板，可以用來快速的建立應用。而 React 也提供了一個名為 <a href="https://github.com/facebookincubator/create-react-app">create-react-app</a> 的工具來快速搭建環境。</p>
<p>遺憾的是，大部分的官方 hello,world 都不是很詳細，這時候我們可以在 GitHub 上搜尋 xxx starter kit 來做同樣的事，如 React Starter Kit，就可以輕鬆地在 GitHub 上找到相就的項目，如<a href="https://github.com/coryhouse/react-slingshot">react-slingshot</a></p>
<figure>
<img src="images/react-starter-kit.jpg" alt="react-starter-kit.jpg" /><figcaption>react-starter-kit.jpg</figcaption>
</figure>
<p>它提供了一些豐富的組合，如 React、Reactd Router、Redux、Babel、Jest、WebPack 等等的工具。現在，我們在這一步要做的事情就是執行起 hello,world。然後，我們再考慮下一步要做一些什麼？</p>
<h3 id="做點什麼應用">做點什麼應用</h3>
<p>拿到框架的下一個問題時，我們要去做什麼，這個就相當有趣了。挑一個有難度的吧，做不了；挑一個簡單的吧，覺得不能練手；還是挑一個實用的吧，比如部落格。</p>
<p>我寫過最多的應用就是與部落格相關的應用了。當出現一個新的練手框架時，我總會用這個框架來把部落格寫一遍。於是，我的部落格的後臺 API 用 Node.js、Flask、Django 實現過一遍，而前臺則用 Backbone、Angular 1、React 實現過一遍，而 APP 方面也使用 Ionic 1 和 React Native 實現過一遍。</p>
<p>對於部落格而言，我們都很輕鬆它的功能：列表頁、詳情頁、登入、建立部落格等等。我通常只會實現上面的四個基本元素，這和大部分應用的主要模式差不多。對於前端來說，我們會練習到基本的內容：</p>
<ul>
<li>GET 和 POST 資料</li>
<li>列表頁到詳情頁的跳轉和返回</li>
<li>對於使用者登入憑據的獲取和儲存</li>
</ul>
<p>基本上涉及到了一個框架的大部分內容，路由、模板、API 請求、資料儲存、使用者授權等等。這樣一來，我們就要清楚地業務邏輯了，那麼剩下的是都是技術的事。</p>
<h3 id="編寫一個部落格應用">編寫一個部落格應用</h3>
<p>接下來，唯一的問題是：因為對這一系列的技術棧，我們會遇到一系列的困難。當一個新手選擇 React 的時候，就會遇到 JSX ES6 Babel Webpack Redux React-Router 等一系列的 React 全家桶。這時，難以下手的主要原因是，不知道這些東西都是幹嘛的，也對前端單應用應用沒有一個清楚的認識。</p>
<p>在沒有基礎的情況下，直接下手這些會有一定的困難：<strong>在學習新的技術棧的同時，也在學習前端應用的組成</strong>。因此：</p>
<p>首先，要對前端單頁面應用有一個大致的瞭解。如對於一個前端框架來說， 它要有模板引擎、依賴管理、路由處理、控制器（模板）和狀態等等，除此它還需要有構建工具、編譯工具、測試框架等等。</p>
<p>然後，就需要了解所使用的工具對應的有什麼功能。如上面說到的例子裡，JSX 相當於是模板引擎、WebPack 是打包工具 / 構建工具、Babel 是 ES6 語言的編譯器、Redux 用來做狀態管理、React-Router 用來處理路由。</p>
<p>最後，需要一個應用的例子來將這些內容串在一起。如當我們開啟一個 Web 應用的時候，應該要有一個路由處理的工具，來將使用者導向相應的頁面。而這個頁面會有對應的控制器和模板，路由就是來分發使用者的請求。當頁面資料資料或者使用者操作時，頁面上的資料狀態就會發生變化，這時就需要狀態管理工具來管理。</p>
<p>幸運的是，我們已經有了一個 starter kit，在這個 starter kit 中會為我們做好相應的配置。因此，我們可以直接閱讀程式碼來了解它們的關係，逐一的瞭解他們的功能。過程有點痛苦，結局便是大豐收。</p>
<p>這一個過程裡，還有一個難點是，我們缺少資料。這時候，我們可以用 moco、MockServer 等工具來做一個假的伺服器，以向我們的應用提供資料。</p>
<h3 id="輸入和總結">輸入和總結</h3>
<p>編寫應用的時候，我們將一個又一個的內容放到了腦子裡，然後發現自己混亂了。需要重新理清他們的關係，這時候可以選擇寫部落格、畫思維導圖、做分享的形式來整理。</p>
<p>當我們向別人講述一個東西的時候，就不得不壓迫自己對此有更深入的瞭解，要不只能丟臉。這時候，我們又在重新學習這些內容，並且比以往的任何時間更加深入。這也就是為什麼我喜歡寫作的原因，它能讓我的思路更加清晰。<strong>原本只是散落在房間裡的書籍，現在整整齊齊的排列在了書架上</strong>。在需要的時候，我就可以找到想要的內容。而由於部落格的存在，我可以在未來輕鬆地瞭解這個框架，別人需要的時候，也可以直接分享相應的經驗。</p>
<p>等閒了，逛逛官方的文件，還會發現：原來這個地方可以這麼用；原來某個地方還可以做得更好。</p>
<h2 id="其它">其它</h2>
<p>假如，我們將前端和後臺所要求的能力做一些對比，我們會發現前端在高階領域比後臺簡單一些。我的意思是，前端要在程式設計方面遇到瓶頸更快，並且需要從其他方面來補充，如後臺，又或者是使用者體驗設計。</p>
<h3 id="關於練手項目">關於練手項目</h3>
<p>在那一篇《<a href="https://github.com/phodal/articles/issues/19">關於程式設計，你的練習是不是有效的</a>》中，我提到，提升技能的項目會有四種：</p>
<ul>
<li>純興趣驅動的項目。即我的Idea列表上的一個個酷炫的項目，先滿足自己再說。</li>
<li>理論驅動的項目。這一類的項目會比較少，因為我們需要牽強地驅動出這樣的項目，然後以理論的方式驅動它。</li>
<li>興趣結合理論型。有一個長長的Idea列表，難免有些時間會和將要學習的理論有很大的交集。這種的練習效果是最好的。</li>
<li>整合成文章、電子書。這一步主要是為了分享、鞏固知識點、討論。</li>
</ul>
<h1 id="前後端分離你應該知道的八件事">前後端分離，你應該知道的八件事</h1>
<blockquote>
<p>前後端不分離，是怎樣的？大概也只有我們這些『老古董』們，才對此有更多感受。不對，那些寫 React 的人，可能會對此也有一些體會。</p>
</blockquote>
<p>今天，如果有一個前端工程師說，不知道前後端分離是什麼。那麼，要麼是剛畢業不久的，要麼是從老版的公司裡出來的員工，要麼是剛從時光機裡出來的。</p>
<h2 id="前後端分離">前後端分離</h2>
<p>我剛開始接觸前後端分離的時候，正值它開始慢慢擴散的時候，也還沒有意識到它帶來的好處。覺得它甚是麻煩，當我改一個介面的時候，我需要同時修改兩部分的程式碼，以及對應的測試。反而，還不如直接修改原有的模板來得簡單。</p>
<p>可是當我去使用這個，由前後端分離做成的單頁面應用時，我開始覺得這些是值得。當頁面載入完後，每開啟一個新的連結時，不再需要等網路返回給我結果；我也能快速的回到上一個頁面，像一個 APP 一樣的體現這樣的應用。整個過程裡，我們只是不斷地從後臺去獲取資料，不需要重複地請求頁面——因為這些頁面的模板已經存在本地了，我們所缺少的只是實時的資料。</p>
<p>後來，當我從架構去考慮這件事時，我才發現這種花費是值得的。</p>
<h3 id="什麼是前後端分離">什麼是前後端分離？</h3>
<p>前後端分離和微服務一樣，漸漸地影響了新的大型系統的架構。微服務和前後端分離要解決是類似的問題，<strong>解耦</strong>——可以解耦複雜的業務邏輯，解耦架構。可要是說相像吧，訊息隊伍和前後端便相似一些，通過傳遞資料的形式來解耦元件。</p>
<p>前後端分離意味著，<strong>前後端之間使用 JSON 來交流，兩個開發團隊之間使用 API 作為契約進行互動</strong>。從此，後臺選用的技術棧不影響前臺。當後臺開發人員選擇 Java 的時候，我可以不用 JSP 來編寫前端頁面，繼續使用我的 React 又或者 Angular。而我使用 React 時，也不影響後臺使用某一個框架。</p>
<p>概念我們已經清楚了，但是還有一個問題：我們真的需要前後端分離嗎？</p>
<h3 id="真的需要前後端分離嗎">真的需要前後端分離嗎？</h3>
<p>過去，聽說 TDD (Test-driven development，測試驅動開發) 可以改善程式碼的質量，我們便實施了 TDD；接著，聽說 BDD (Behavior-driven development，行為驅動開發) 可以交付符合業務需求的軟體，我們便實施了 BDD；後來，聽說 DDD (Domain-driven design，領域驅動設計) 可以分離業務程式碼與基礎程式碼，我們便實施了 DDD。今天，聽說了前後端分離很流行，於是我們就實施了前後端分離——這就是傳說中的 HDD（Hype-driven Development，熱鬧驅動開發）。</p>
<p>前後端分離在過去的兩三年裡，確實特別的熱鬧。但是我們怎麼才能知道，是不是需要這樣的架構呢？</p>
<ul>
<li><strong>頁面互動是否複雜 ？</strong> 是簡單的提供頁面給使用者瀏覽？或者想要支援複雜的使用者操作？</li>
<li><strong>是否需要搜尋引擎優化？</strong>如果需要的話，那麼從一開始我們就需要考慮後端渲染。</li>
<li><strong>能提升開發效率嗎？</strong>如果不能有效的提升開發效率，為什麼要作死呢？</li>
<li><strong>是否會提供 API 給 APP？</strong>如果我們已經有一個 API 提供給 APP，那麼要做這件事就很容易了。如果未來會有的話，那麼我們更應該嘗試去分離。</li>
<li><strong>前端的修改是不是非常頻繁？</strong>如果不需要經常修改的話，那麼這種優化便沒有優勢。</li>
</ul>
<p>當然了，如果老闆說，我們需要前後端分離，那就做唄！很多時候，一些技術決策都會由於戰略原因，而發生一些有意思的變化。</p>
<h3 id="前後端分離將遇到的那些挑戰">前後端分離將遇到的那些挑戰</h3>
<p>而，當我們決定需要前後端分離時，我們仍然還需要面對一系列的問題：</p>
<ul>
<li><strong>是否足夠的安全？</strong>如果我們設計出來的架構不夠安全，那麼這一系列的操作都是白搭。我們怎麼去儲存使用者資料，使用 LocalStorage 的話，還要考慮加密。採用哪種認證方式來讓使用者登入，並儲存相應的狀態？</li>
<li><strong>是否有足夠的技術來支撐前後端分離？</strong>有沒有能力建立出符合 RESTful 風格的 API？</li>
<li><strong>是否有能力維護 API 介面？</strong>當前端或者後臺需要修改介面時，是否能輕鬆地修改。</li>
<li><strong>前後端協作的成本高不高？</strong>前端和後臺兩個團隊是不是很容易合作？是不是可以輕鬆地進行聯調？</li>
<li><strong>前後端職責是否能明確？</strong>即：<strong>後臺提供資料，前端負責顯示</strong>。</li>
<li><strong>是否建立了前端的錯誤追蹤機制？</strong>能否幫助我們快速地定位出問題。</li>
</ul>
<p>當我們在不同的項目組上嘗試時，就會發現主要的挑戰是溝通上的挑戰，而非技術上的侷限。</p>
<h2 id="前後端分離的核心後臺提供資料前端負責顯示">前後端分離的核心：後臺提供資料，前端負責顯示</h2>
<p>我曾經有過使用 PHP 和 Java 開發後臺程式碼的經歷，仍然也主要是集中在前端領域。在這樣的傳統架構裡，編寫前端頁面可不是一件容易的事。後臺只會傳給前端一個 ModelAndView，然後前端就要撲哧撲哧地去豐富業務邏輯。</p>
<p>傳統的 MVC 架構裡，因為某些原因有相當多的業務邏輯，會被放置到 View 層，也就是模板層裡。換句話來說，就是這些邏輯都會被放到前端。我們看到的可能就不是各種<code>if</code>、<code>else</code>還有簡單的<code>equal</code>判斷，還會包含一些複雜的業務邏輯，比如說對某些產品進行特殊的處理。</p>
<p>如果這個時候，我們還需要做各種頁面互動，如填寫表單、Popup、動態資料等等，就不再是簡單的和模板引擎打交道了。我們需要編寫大量的 JavaScript 程式碼，因為業務的不斷增加，僅使用 jQuery 無法管理如此複雜的程式碼。</p>
<h3 id="輸出邏輯資料顯示">輸出邏輯：資料顯示</h3>
<p>而僅僅只是因為邏輯複雜的前端程式碼，無法影響大部分團隊進行前後端分離——因為它沒有業務價值。實際上是先有了單頁面應用，才會出現前後端分離。單頁面應用可以讓使用者不需要下載 APP，就可以擁有相似的體現。並且與早期的移動網頁相比，擁有更好的體驗。</p>
<p>為了達到這樣的目的，後臺似乎返回對應的 Model 即可，稍微修改一下 Controller 的邏輯，然後返回這些資料。</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">[<span class="op">{</span>
    <span class="st">&quot;content&quot;</span><span class="op">:</span> <span class="st">&quot;&quot;</span><span class="op">,</span>
    <span class="st">&quot;date&quot;</span><span class="op">:</span> <span class="st">&quot;2017-03-04&quot;</span><span class="op">,</span>
    <span class="st">&quot;description&quot;</span><span class="op">:</span> <span class="st">&quot;前後端分離，你應該知道的八件事</span><span class="sc">\r\n\r\n</span><span class="st">前後端不分離，是怎樣的？大概也只有我們這些『老古董』們，才對此有更多感受。不對，那些寫 React 的人，可能會對此也有一些體會。&quot;</span><span class="op">,</span>
    <span class="st">&quot;id&quot;</span><span class="op">:</span> <span class="dv">1</span><span class="op">,</span>
    <span class="st">&quot;slug&quot;</span><span class="op">:</span> <span class="st">&quot;iamafe-frontend-backend&quot;</span><span class="op">,</span>
    <span class="st">&quot;title&quot;</span><span class="op">:</span> <span class="st">&quot;我的職業是前端工程師:  前後端分離，你應該知道的八件事&quot;</span><span class="op">,</span>
    <span class="st">&quot;user&quot;</span><span class="op">:</span> <span class="st">&quot;&quot;</span>
<span class="op">}</span>]</code></pre></div>
<p>前端在一個 API 請求之後，可以直接渲染這些資料成 HTML。在這個時候，我們仍然可以看到，上面資料中的 date 欄位值 2017-03-04 的格式，和我們日常用的 2017 年 3 月 4 號的不一樣。所以，我們需要在前端引入 <code>moment</code> 這樣的庫，然後解析這個值。如果僅僅是這樣的處理，那麼應該由後臺幫我們轉換這個值。</p>
<p>與此同時，後臺應該按時間來對部落格進行排序。前端只需要遍歷這個陣列，隨後取出相應的值顯示即可，不需要做任何的邏輯處理。</p>
<p>遺憾的是，在真正的項目中開發的時候，並不能達到這麼完美的狀態。特別是，為了提高使用者體驗時，我們可能就會將資料儲存在本地，隨後直接操作這些資料，對其進行排序，篩選等等的操作。除此，還有諸如表格、圖表等等的高階樣式，也需要處理這些資料。</p>
<p>而當使用者需要提交資料的時候，這些邏輯就會落到前端上。</p>
<h3 id="不可避免的前端邏輯表單">不可避免的前端邏輯：表單</h3>
<p>如果一個前端應用只顯示資料的話，那麼這個應用就沒有充足的理由，做成一個單頁面應用——單頁面應用是為了更好的互動而存在的。當我們註冊、登入、購買東西時，就需要開始與表單進行處理。</p>
<p>合理的表單驗證模式應該是：<strong>雙向驗證</strong>。</p>
<p>前端在使用者輸入的過程中就需要實時地檢查，是否帶有特殊符號、值是否是在允許的範圍內、是不是符合相應的規範等等。而不是等使用者填寫完內容並提交後，再由服務端來告訴使用者說，“你的使用者名稱不符合規範”。</p>
<p>服務在收到前端收到的資料後，不管前端有沒有進行驗證，都應該按後臺的邏輯進行驗證。</p>
<p>於是乎在這個時候，這些邏輯就被無可避免地放到前臺裡了。</p>
<h1 id="seo-優化技巧-如何設計一個高質量的-url-及頁面標題">SEO 優化技巧 ：如何設計一個高質量的 URL 及頁面標題</h1>
<blockquote>
<p>今天，很多網站的 URL 的設計都是有問題的——因為 RESTful。依據 RESTful API 原則，我們設計出來的 API 的 URL 都會有這樣那樣的缺陷。</p>
</blockquote>
<ul>
<li></li>
</ul>
<blockquote>
<p>在過去的幾年裡，搜尋引擎的影響力發生了一些變化——其影響力的趨勢是逐漸變弱。應用程式已經變成了流量的一個大入口，當然搜尋引擎也還是一個大的入口。搜尋引擎優化看上去並沒有那麼重要，企業靠活動、運營來挖掘新的使用者。可當所有的人不重視，而我們重視的時候，那麼這個流量入口就是我們的天下。</p>
</blockquote>
<p>自打我開始寫部落格起（大概是在 2011 年左右），便開始研究搜尋引擎優化（Search Engine Optimization）。這項看似不重要的技術，卻為我的部落格帶來 了大量的流量。</p>
<p>工作之後，我才發現這是一門大生意——為了排在搜尋引擎靠前的位置，每個網站每天都在不斷的送錢給 Google、百度、Bing 等搜尋引擎公司。當我們在 Google、百度上點選一下，首頁上的某個推廣連結，可能就會為它們帶去幾十美刀的收入。要是能競爭到此，那說明這個行業相當的賺錢。同時，處在這個行業的人吶也越來越不賺錢了——他們都把錢交給了科技公司了。</p>
<h2 id="搜尋引擎優化都是前端的活">搜尋引擎優化都是前端的活</h2>
<p>如我們在引言裡所說的，搜尋引擎的流量在逐漸地減弱，但是這<strong>幾乎</strong>是一種一勞永逸的方式。只需要制定一個合理的 SEO 策略，再瞧瞧看競爭對手的規則、使用者的習慣等等。我們就可以坐等：使用者從搜尋引擎來到我們的網站。隨後的日子裡，只需要跟蹤使用者行為的變化，再做出一些適當的改變即可。</p>
<p>在決定玩搜尋引擎優化之前，我們仍然得判斷是不是需要搜尋引擎優化。對於那些網站流量依賴於搜尋引擎的網站來說，搜尋引擎優化必要的，這樣的網站有以內容為主的網站，如各種部落格、知識問題類網站，網站的主要功能也是搜尋的網站，如各種手機、電腦、房產網站等等。而對於大到一定體量的網站——使用者已經有這個品牌意識的時候，他們對沒有多大必要進行搜尋引擎優化，而是更關注於如何提高使用者體驗。</p>
<p>當我們決定為網站進行搜尋引擎優先的時候，需要執行一系列相關的調查、設計，並著手開始修改程式碼，上線，隨後再分析線上的情況，不斷的改進系統。系統以一種精益的模式在執行著：</p>
<figure>
<img src="images/lean.png" alt="Lean" /><figcaption>Lean</figcaption>
</figure>
<p>而完成這部分的主要工作，都是在前端的頁面模板上。而在那之前，我們得保證：我們的 Web 應用可以支援後臺渲染。</p>
<blockquote>
<p>如果當前的單頁面應用不支援後臺渲染，可以參考我之前寫的文章《<a href="https://github.com/phodal/articles/issues/20">單頁面應用後臺渲染的三次實踐</a>》來完善後臺渲染的機制。</p>
</blockquote>
<p>作為一個前端工程師，我們需要做一系列的工作：</p>
<ul>
<li>設定好 HTML 中的 Title、URL、Keywords、Description</li>
<li>頁面中的內容是否可以正常顯示。如果內容是動態生成的，那麼整個系統對於搜尋引擎的體驗將會特別。儘管 Google 可以動態的渲染頁面，但是仍然會有一些影響。</li>
<li>頁面的內容是否以推薦的 HTML 標籤寫的。如只有一個 H1 用於作內容的標題，多個 H1 標籤可能會造成和 Title 不一致，導致顯示在搜尋引擎上的結果有誤。</li>
<li>頁面中的內鏈是否分配得合理。頁面中是不是會有指向重要頁面的連結，如首頁。或者每個分類的詳情頁都會有連結，並連結到列表頁。這樣一來，列表頁的排名就會比較高。</li>
<li>判斷頁面中的外鏈是否需要 nofollow 標籤。</li>
<li>如果有獨立的移動站點，要檢測一下，是不是需要 rel=“canonical” 來表明他們的關係。</li>
<li>是否需要採用 rel=“next” 和 rel=“preve” 來指明頁面間的關係，以讓第一頁擁有較高的排名。同時還能為瀏覽器開啟 Prefetch 功能。</li>
<li>等等</li>
</ul>
<p>我們需要做的活有一大堆。不過，考慮到這不是一本詳細的 SEO 書籍，我們將關注於基礎的部分：設定好 HTML 中的 Title、URL、Keywords、Description。</p>
<h2 id="如何設計一個高質量的-url">如何設計一個高質量的 URL</h2>
<p>今天，很多網站的 URL 的設計都是有問題的。它們看起來一塌糊塗，彷彿是被人洗掉的髒資料一樣，沒有經過設計，沒有經過思考。他們一點都不適合閱讀，也不利於搜尋引擎優化。</p>
<p>剛開始寫部落格的時候，我從來不會想著去自定義一個 URL。想好一個標題，沒有敲好內容就直接提交了，可這個時候生成的 URL 總是很詭異。當我們去設計一個部落格的時候，URL 是一個頭疼的問題。設計之下，每個人選擇的方案都有所不同：</p>
<ul>
<li>直接使用部落格的 ID，如 /blog/123，即省事又方便</li>
<li>自動生成 URL</li>
<li>將標題轉換為拼音或者英語單詞，如 blog/ruhe-sheji-yige-gaozhilang-de-url</li>
<li>根據日期和 ID 生成，諸如 blog/2017/02/123</li>
<li>等等</li>
<li>自定義 URL，諸如 blog/how-to-design-a-high-quality-url。如果要考慮到一些推薦的 URL 設計原因，如介詞，這個 URL 應該變成 howto-design-hight-quality-url。</li>
</ul>
<p>也因此，我們會發現大部分的架構設計裡，都忽略了對 URL 的設計——只是為了更加方便的使用 RESTful。</p>
<h3 id="受-restful-api-影響-的-url-設計">受 RESTful API 影響 的 URL 設計</h3>
<p>依據 RESTful API 原則，我們設計出來的 API 的 URL 都會有這樣的缺陷。如下是 RESTful API 設計的一個簡單的例項：</p>
<table>
<thead>
<tr class="header">
<th>動作</th>
<th>URL</th>
<th>行為</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>GET</td>
<td>/blog</td>
<td>獲取所有的文章（PS：實踐的時候，通常會採用分頁機制）</td>
</tr>
<tr class="even">
<td>GET</td>
<td>/blog/:id</td>
<td>獲取某一個具體的文章</td>
</tr>
<tr class="odd">
<td>PUT</td>
<td>/blog/:id</td>
<td>更新某一個具體的文章</td>
</tr>
<tr class="even">
<td>POST</td>
<td>/blog</td>
<td>建立一個新的文章</td>
</tr>
<tr class="odd">
<td>DELETE</td>
<td>/blog/:id</td>
<td>刪除某一個具體的文章</td>
</tr>
</tbody>
</table>
<p>最後，我們設計出來的文章地址，可能就是 blog/123，又或者是 blog/58c286d7ac502e0062d7c84e。因為，我們是依據這個 ID 到資料庫去操作（CRUD）相應的值。ID 本身是自增的，並且是唯一的，所以這種設計因此就比較簡單了。因此，我們到資料去查詢的時候，我們只需要<code>where id=&quot;123&quot;</code>即可。</p>
<p>可是對於一個部落格來說，<strong>每個部落格的連結都是唯一</strong>的。因此，我們仍然可以使用``where slug=“how-to-design-a-high-quality-url”。</p>
<p>於是，自定義 URL 就是其中的一種形式。</p>
<h3 id="手動自定義-url">手動自定義 URL</h3>
<p>與 URL 相比，ID 本身是不如記的。如我的專欄《我的職業是前端工程師》 的豆瓣上的連結是：<a href="https://read.douban.com/column/5945187/" class="uri">https://read.douban.com/column/5945187/</a> ，而在知乎上則是 <a href="https://zhuanlan.zhihu.com/beafe" class="uri">https://zhuanlan.zhihu.com/beafe</a>。試問一下，如果要記下來的話，哪個更輕鬆？</p>
<p>以我的部落格為例，正常的 URL 是這樣的，<a href="https://www.phodal.com/blog/use-jenkinsfile-blue-ocean-visualization-pipeline/" class="uri">https://www.phodal.com/blog/use-jenkinsfile-blue-ocean-visualization-pipeline/</a>，對應的標題是：<a href="https://www.phodal.com/blog/use-jenkinsfile-blue-ocean-visualization-pipeline/">Jenkins 2.0 裡使用 Jenkinsfile 設計更好的 Pipeline</a>，這種設計本身可以將關鍵詞融入 URL ，就更容易換得一個好的排名：</p>
<figure>
<img src="images/jenkins-pipeline-example.png" alt="Google jenkins 2.0 pipeline" /><figcaption>Google jenkins 2.0 pipeline</figcaption>
</figure>
<p>這裡的 use-jenkinsfile-blue-ocean-visualization-pipeline 就是優化的部分。而為了設計方便，大部分的部落格都會將 URL 設計成 /blog/123。結果便是，當使用者搜尋 jenkinsfile 和 pipline 時，就出現了一些劣勢。</p>
<p>對應的，使用漢字搜尋為主的中文網站來說，使用 wo-de-zhiye-shi-qianduan-gongchenshi 可能是一種更不錯的選擇。我們只需要使用一些分詞庫，就可以生成對應的中文拼音 URL。</p>
<p>當我們有大量的商品的時候，手動定義可能會讓人有些厭煩。於是我們應該定義一些規則，然後生成相對應的 URL。</p>
<h3 id="詳情頁-簡單的-url-生成規則">詳情頁 ：簡單的 URL 生成規則</h3>
<p>考慮到手動生成的難度，以及一些 RESTful 設計的風格問題，我們可以考慮結合他們的形式，諸如：</p>
<table>
<thead>
<tr class="header">
<th>動作</th>
<th>URL</th>
<th>行為</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>GET</td>
<td>/blog/:id/:blog-slug</td>
<td>獲取某一個具體的文章</td>
</tr>
</tbody>
</table>
<p>是的，只需要改進一下 URL 生成的規則就可以了。StackOverflow 採用的就是這種設計，當我們從 Google 訪問一個 URL 的時候，我們訪問的地址便是：<strong>questions/:question-id/:question-slug</strong> 這種形式，其中的 id 和 slug 都是自動生成的，如：</p>
<pre><code>questions/20381976/rest-api-design-getting-a-resource-through-rest-with-different-parameters-but</code></pre>
<p>而當我們使用 question/:question-id 的形式訪問時，諸如 questions/20381976，就會被永久重定向到上面的帶 slug 的地址。</p>
<p>與手動相比，使用這種方式，即可以保證 URL 的質量，又可以減輕後臺的負擔——我們不根據 URL 來獲取資料，我們仍然使用 ID 來獲取資料，仍然可以對資料進行快取。</p>
<p>而 RESTful 原則主要解決的問題是：對於資源的分類。，我們就需要一些更高階的 URL 設計。</p>
<h3 id="自動化-url分類與多級目錄">自動化 URL：分類與多級目錄</h3>
<p>假使我們的網站上擁有大量的商品時，那麼我們採用 RESTful 來描述資源時，這個時候路徑可能就會變成這樣：</p>
<pre><code>/markets/3c/sj/meizu/meizu-mx5</code></pre>
<p>如果不考慮搜尋引擎優化，這個 URL 本身是沒有什麼毛病的，除了：<strong>分類有點多</strong>。</p>
<p>分類多對於 SEO 來說，主要問題就是，Page Rank 會被分配到不同的分類上，而導致當前頁面的 Page Rank 比較低。因而，對於不同的網站來說可能有不同的策略需求。有的網站可能需要主目錄的 Rank 比較高，有的網站則需要詳情頁的 Rank 值比較高，因此也沒有一個好的定論：</p>
<ul>
<li>如果希望詳情頁的 Rank 比較高，那麼應該減少分類</li>
<li>如果需要分類的 Rank 比較高，那麼這樣設計就是合理的</li>
</ul>
<h3 id="搜尋結果頁將參數融入-url">搜尋結果頁：將參數融入 URL</h3>
<p>在上面的例子中，因為部落格都是唯一的，所以要配置一個唯一的參數都是比較簡單的。當我們需要搜尋結果時，情況就變得有些複雜——我們需要搜尋和過濾。</p>
<p>對於一個使用 RESTful API 表示的搜尋結果頁，我們會這樣去配置它的 URL：</p>
<pre><code>http://www.xxx.com/search/?q={keyword}&amp;page={page}&amp;size={size}</code></pre>
<p>然後，再我們的 Link Header 裡指定下一頁的結果就可以了。這樣的 API 設計看上去，非常適合我們的場景。使用者在篩選條件裡選好想要的條件，再填入關鍵詞就可以了。</p>
<p>現在讓我們來假設一種使用者場景，我們想搜尋一個 100~150 元左右的 移動電源，並且它還是深圳產的。這個時候，網頁返回的 URL 可能就是：</p>
<pre><code>search/?minPrice=100&amp;maxPrice=150&amp;product=powerbank&amp;location=shenzhen&amp;page=1</code></pre>
<p>這個時候索引的結果，可就失去了分類的意義了。於是，我們需要一個更好的 URL，諸如：</p>
<pre><code>product/powerbank/?minPrice=100&amp;maxPrice=150&amp;location=shenzhen&amp;location=shenzhen</code></pre>
<p>那麼，對於 URL 索引的 Rank 將會加給 powerbank，點選量 + 頁面數量可以讓它有一個好的排名：</p>
<p>當然諸如淘寶、京東這樣的網站就不需要這麼做了，他們對於 SEO 的需求沒有這麼強烈——因為要在百度上排個好名，可不止 SEO 的事了。</p>
<p>而如果我們願意的話，還可以將參數融入到 URL 中，powerbank/range-100-150-city-shenzhen/page-1。這樣，不止移動電源上有一個好的排名，100~150 元的移動電源也可以有一個好的排名。這時候，我們需要使用正則來匹配這些規則，一個簡單的示例<code>(\S+)-range-(\d+)-(\d+)-city-(\S+)</code>，匹配結果如下：</p>
<figure>
<img src="images/seo-match-example.png" alt="SEO URL" /><figcaption>SEO URL</figcaption>
</figure>
<p>但是，不管怎樣這些參數帶來的影響，都是相當微弱的。正在要做好的是網站本身，以及相關的站點結構設計、網站內容。</p>
<h2 id="自動生成高質量的站點標題">自動生成高質量的站點標題</h2>
<h3 id="什麼是站點標題">什麼是站點標題？</h3>
<p>就是我們在搜尋結果頁看到的那個標題。</p>
<figure>
<img src="images/title-example.jpg" alt="站點標題" /><figcaption>站點標題</figcaption>
</figure>
<p>如上圖所示的結果，是我用 Google 搜尋：“程式設計師如何提高影響力”得到的結果。對應的第一個連結的，<code>如何提高影響力- Phodal | Phodal - A Growth Engineer</code> 就是我部落格的站點標題。對應在 HTML 中就是 title 標題：</p>
<figure>
<img src="images/phodal-com-seo.png" alt="Phodal’s COM SEO" /><figcaption>Phodal’s COM SEO</figcaption>
</figure>
<h3 id="什麼才算一個高質量的站點標題">什麼才算一個高質量的站點標題？</h3>
<p>這是一個很趣的問題。我想應該是在標題裡，帶有我想要的資訊吧。對於一篇部落格來說，我可能想看到的內容有：文章的標題，站點的簡單介紹，誰的網站等等的內容。</p>
<p>如上圖中的我的部落格的標題，就是一個不錯的示例。標題裡帶有：文章的標題，作者名、站點名、站點簡介，即：<code>文章標題 - 作者名 | 站點名 - 站點簡介</code>。上圖中的 SegmentFault 的標題也相當的不錯，<code>文章標題 - 專欄標題 - 站點名</code>。而知乎的專欄，就沒有那麼有趣了：<code>程式設計師如何提高影響力2.0 - 知乎專欄</code>。</p>
<p>有了上面的例子之後，要完成一個相似的站點標題就更新增容易了：即將產品的相關資訊帶入到標題裡。上面的例子中的 Title 看上去都有點生硬，如果我們願意的話，我們也可以對其進行優化。</p>
<p>該說的我們都說了，最後再來說說為什麼吧。如下是 Google 搜尋結果中的使用者熱圖：</p>
<figure>
<img src="images/heat-map-2005-2014.jpg" alt="Google Heat Map" /><figcaption>Google Heat Map</figcaption>
</figure>
<p>儘管發生了一些變化，但是我們會發現：使用者仍然集中注意力在左側區域，即文章的標題部分。也就是說，我們應該將標題放在最左邊，而與搜尋無關的網站資訊放在最右邊。</p>
<p>所以，標題的形式應該是：文章標題 - 各種相關資訊。由於 Title 標籤擁有比較重要的作用，所以在不影響讀者閱讀的時候，應該儘可能地把相關的資訊放進去。</p>
<h1 id="你應該知道的單頁面應用的核心知識">你應該知道的單頁面應用的核心知識</h1>
<blockquote>
<p>這幾年裡，單頁面應用的框架令人應接不暇，各種新的概念也層出不窮。從過去的 jQuery Mobie、Backbone 到今天的 Angular 2、React、Vue 2，除了版本號不同，他們還有很多的相同之處。</p>
</blockquote>
<p>剛開始寫商業程式碼的時候，我使用的是 jQuery。使用 jQuery 來實現功能很容易，找到一個相應的 jQuery 外掛，再編寫相應的功能即可。對於單頁面應用亦是如此，尋找一個相輔助的外掛就可以了，如 jQuery Mobile。</p>
<p>儘管在今天看來，jQuery Mobile 已經不適合於今天的多數場景了。這個主要原因是，當時的使用者對於移動 Web 應用的理解和今天是不同的。他們覺得移動 Web 應用就是針對移動裝置而訂製的，移動裝置的 UI、更快的載入速度等等。而在今天，多數的移動 Web 應用，幾乎都是單頁面應用了。</p>
<p>過去，即使我們想建立一個單頁面應用，可能也沒有一個合適的方案。而在今天，可選擇的方案就多了（PS：參見《第四章：學習前端只需要三個月【框架篇】》）。每個人在不同類型的項目上，也會有不同的方案，沒有一個框架能解決所有的問題</p>
<ul>
<li>對於工作來說，我更希望的是一個完整的解決方案。</li>
<li>對於程式設計體驗來說，我喜歡一點點的去創造一些輪子。</li>
</ul>
<p>當我們<strong>會用的框架越多的時候， 所花費的時間抉擇也就越多</strong>。而單頁面應用的都有一些相同的元素，對於這些基本元素的理解，可以讓我們更快的適合其他框架。</p>
<h2 id="單頁面應用的演進">單頁面應用的演進</h2>
<p>我接觸到單頁面應用的時候，它看起來就像是<strong>將所有的內容放在一個頁面上麼</strong>。只需要在一個 HTML 寫好所需要的各個模板，並在不同的頁面上 data-role 表明這是個頁面（基於 jQuery Mobile）——每個定義的頁面都和今天的移動應用的模式相似，有 header、content、footer 三件套。再用 id 來定義好相應的路由。</p>
<pre><code>&lt;div data-role=&quot;page&quot; id=&quot;foo&quot;&gt;
...
&lt;/div&gt;</code></pre>
<p>這樣我們就在一個 HTML 裡返回了所有的頁面了。隨後，只需要在在入口處的 href 裡，寫好相應的 ID 即可。</p>
<pre><code>&lt;a href=&quot;#foo&quot;&gt;跳轉到foo&lt;/a&gt;</code></pre>
<p>當我們點選相應的連結時，就會切換到 HTML 中相應的 ID。這種簡單的單頁面應用基本上就是一個離線應用了，只適合於簡單的場景，可是它帶有單頁面應用的基本特性。而複雜的應用，則需要從伺服器獲取資料。然而早期受限於移動瀏覽器效能的影響，只能從伺服器獲取相應的 HTML，並替換當前的頁面。</p>
<p>在這樣的應用中，我們可以看到單頁面應用的基本元素： <strong>頁面路由</strong>，通過某種方式，如 URL hash 來說明表明當前所在的頁面，並擁有從一個頁面跳轉到另外一個頁面的入口。</p>
<p>當移動裝置的效能越來越好時，開發者們開始在瀏覽器裡渲染頁面：</p>
<ul>
<li>使用 jQuery 來做頁面互動</li>
<li>使用 jQuery Ajax 來從服務端獲取資料</li>
<li>使用 Backbone 來負責路由及 Model</li>
<li>使用 Mustache 作為模板引擎來渲染頁面</li>
<li>使用 Require.js 來管理不同的模板</li>
<li>使用 LocalStorage 來儲存使用者的資料</li>
</ul>
<p>通過結合這一系列的工具，我們終於可以實現一個複雜的單頁面應用。而這些，也就是今天我們看到的單頁面應用的基本元素。我們可以在 Angular 應用、React 應用、Vue.js 應用 看到這些基本要素的影子，如：Vue Router、React Router、Angular 2 RouterModule 都是負責路由（頁面跳轉及模組關係）的。在 Vue 和 React 裡，它們都是由輔助模組來實現的。因為 React 只是層 UI 層，而 Vue.js 也是用於構建使用者介面的框架。</p>
<h2 id="路由頁面跳轉與模組關係">路由：頁面跳轉與模組關係</h2>
<p>要說起路由，那可是有很長的故事。當我們在瀏覽器上輸入網址的時候，我們就已經開始了各種路由的旅途了。</p>
<ol type="1">
<li>瀏覽器會檢查有沒有相應的域名快取，沒有的話就會一層層的去向 DNS伺服器 尋向，最後返回對應的伺服器的 IP 地址。</li>
<li>接著，我們請求的網站將會將由對應 IP 的 HTTP 伺服器處理，HTTP 伺服器會根據請求來交給對應的應用容器來處理。</li>
<li>隨後，我們的應用將根據使用者請求的路徑，將請求交給相應的函數來處理。最後，返回相應的 HTML 和資源文化</li>
</ol>
<p>當我們做後臺應用的時候，我們只需要關心上述過程中的最後一步。即，將對應的路由交給對應的函數來處理。這一點，在不同的後臺框架的表現形式都是相似的。</p>
<p>如 Python 語言裡的 Web 開發框架 Django 的 URLConf，使用正規表示式來表正</p>
<pre><code>url(r&#39;^articles/2003/$&#39;, views.special_case_2003),</code></pre>
<p>而在 Laravel 裡，則是通過參數的形式來呈現</p>
<pre><code>Route::get(&#39;posts/{post}/comments/{comment}&#39;, function ($postId, $commentId) {
    //
});</code></pre>
<p>雖然表現形式有一些差別，但是總體來說也是差不多的。而對於前端應用來說，也是如此，<strong>將對應的 URL 的邏輯交由對應的函數來處理</strong>。</p>
<p>React Router 使用了類似形式來處理路由，程式碼如下所示：</p>
<pre><code> &lt;Route path=&quot;blog&quot; component={BlogList} /&gt;
 &lt;Route path=&quot;blog/:id&quot; component={BlogDetail} /&gt;</code></pre>
<p>當頁面跳轉到 blog 的時候，會將控制權將給 BlogList 元件來處理。</p>
<p>當頁面跳轉到 blog/fasfasf-asdfsafd 的時候，將匹配到這二個路由，並交給 BlogDetail 元件 來處理。而路由中的 id 值，也將作為參數 BlogDetail 元件來處理。</p>
<p>相似的，而 Angular 2 的形式則是：</p>
<pre><code>{ path: &#39;blog&#39;,      component: BlogListComponent },
{ path: &#39;blog/:id&#39;,      component: BlogDetailComponent },</code></pre>
<p>相似的，這裡的 BlogDetailComponent 是一個元件，path 中的 id 值將會傳遞給 BlogDetailComponent 元件。</p>
<p>從上面來看，儘管表現形式上有所差異，但是其行為是一致的：使用規則引擎來處理路由與函數的關係。稍有不同的是，後臺的路由完全交由伺服器端來控制，而前端的請求則都是在本地改變其狀態。</p>
<p>並且同時在不同的前端框架上，他們在行為上還有一些區別。這取決於我們是否需要後臺渲染，即重新整理當前頁面時的表現形式。</p>
<ul>
<li>使用 Hash （#）或者 Hash Bang （#!） 的形式。即 # 開頭的參數形式，諸如 <a href="http://ued.party/#/blog">ued.party/#/blog</a>。當我們訪問 blog/12 時，URL 的就會變成 <a href="http://ued.party/#/blog/12">ued.party/#/blog/12</a></li>
<li>使用新的 HTML 5 的 history API。使用者看到的 URL 和正常的 URL 是一樣的。當使用者點選某個連結進入到新的頁面時，會通過 history 的 pushState 來填入新的地址。當我們訪問 blog/12 時，URL 的就會變成 <a href="http://ued.party/blog/12">ued.party/blog/12</a>。當使用者重新整理頁面的時候，請通過新的 URL 來向伺服器請求內容。</li>
</ul>
<p>幸運的是，大部分的最新 Router 元件都會判斷是否支援 history API，再來決定先用哪一個方案。</p>
<h2 id="資料獲取與鑑權">資料：獲取與鑑權</h2>
<p>實現路由的時候，只是將對應的控制權交給控制器（或稱元件）來處理。而作為一個單頁面應用的控制器，當執行到相應的控制器的時候，就可以根據對應的 blog/12 來獲取到使用者想要的 ID 是 12。這個時候，控制器將需要在頁面上設定一個 loading 的狀態，然後傳送一個請求到後臺伺服器。</p>
<p>對於資料獲取來說，我們可以通過封裝過 XMLHttpRequest 的 Ajax 來獲取資料，也可以通過新的、支援 Promise 的 Fetch API 來獲取資料，等等。Fetch API 與經過 Promise 封裝的 Ajax 並沒有太大的區別，我們仍然是寫類似於的形式：</p>
<pre><code>fetch(url).then(response =&gt; response.json())
  .then(data =&gt; console.log(data))
  .catch(e =&gt; console.log(&quot;Oops, error&quot;, e))</code></pre>
<p>對於複雜一點的資料互動來說，我們可以通過 RxJS 來解決類似的問題。整個過程中，比較複雜的地方是對資料的鑑權與模型（Model）的處理。</p>
<p>模型麻煩的地方在於：轉變成想要的形式。後臺返回的值是可變的，它有可能不返回，有可能是 null，又或者是與我們要顯示的值不一樣——想要展示的是 54%，而後臺返回的是 0.54。與此同時，我們可能還需要對數值進行簡單的計算，顯示一個範圍、區間，又或者是不同的兩種展示。</p>
<p>同時在必要的時候，我們還需要將這些值儲存在本地，或者記憶體裡。當我們重新進入這個頁面的時候，我們再去讀取這些值。</p>
<p>一旦談論到資料的時候，不可避免的我們就需要關心安全因素。對於普通的 Web 應用來說，我們可以做兩件事來保證資料的安全：</p>
<ol type="1">
<li>採用 HTTPS：在傳輸的過程中保證資料是加密的。</li>
<li>鑑權：確保指定的使用者只能可以訪問指定的資料。</li>
</ol>
<p>目前，流行的前端鑑權方式是 Token 的形式，可以是普通的定製 Token，也可以是 JSON Web Token。獲取 Token 的形式，則是通過 Basic 認證——將使用者輸入的使用者名稱和密碼，經過 BASE64 加密傳送給伺服器。伺服器解密後驗證是否是正常的使用者名稱和密碼，再返回一個帶有時期期限的 Token 給前端。</p>
<p>隨後，當使用者去獲取需要許可權的資料時，需要在 Header 裡鑑定這個 Token 是否有限，再返回相應的資料。如果 Token 已經過期了，則返回 401 或者類似的標誌，客戶端就在這個時候清除 Token，並讓使用者重新登入。</p>
<h2 id="資料展示模板引擎">資料展示：模板引擎</h2>
<p>現在，我們已經獲取到這些資料了，下一步所需要做的就是顯示這些資料。與其他內容相比，顯示資料就是一件簡單的事，無非就是：</p>
<ul>
<li>依據條件來顯示、隱藏某些資料</li>
<li>在模板中對資料進行遍歷顯示</li>
<li>在模板中執行方法來獲取相應的值，可以是函數，也可以是過濾器。</li>
<li>依據不同的數值來動態獲取樣式</li>
<li>等等</li>
</ul>
<p>不同的框架會存在一些差異。並且現代的前端框架都可以支援單向或者雙向的資料繫結。當相應的資料發生變化時，它就可以自動地顯示在 UI 上。</p>
<p>最後，在相應需要處理的 UI 上，綁上相應的事件來處理。</p>
<p>只是在資料顯示的時候，又會涉及到另外一個問題，即元件化。對於一些需要重用的元素，我們會將其抽取為一個通用的元件，以便於我們可以複用它們。</p>
<pre><code>&lt;my-sizer [(size)]=&quot;fontSizePx&quot;&gt;&lt;/my-sizer&gt;</code></pre>
<p>並且在這些元件裡，也會涉及到相應的參數變化即狀態改變。</p>
<h2 id="互動事件與狀態管理">互動：事件與狀態管理</h2>
<p>完成一步步的渲染之後，我們還需要做的事情是：互動。互動分為兩部分：使用者互動、元件間的互動——共享狀態。</p>
<h3 id="元件互動狀態管理">元件互動：狀態管理</h3>
<p>使用者從 A 頁面跳轉到 B 頁面的時候，為了解耦元件間的關係，我們不會使用元件的參數來傳入值。而是將這些值儲存在記憶體裡，在適當的時候調出這些值。當我們處理使用者是否登入的時候，我們需要一個 isLogined 的方法來獲取使用者的狀態；在使用者登入的時候，我們還需要一個 setLogin 的方法；使用者登出的時候，我們還需要更新一下使用者的登入狀態。</p>
<p>在沒有 Redux 之前，我都會寫一個 service 來管理應用的狀態。在這個模組裡寫上些 setter、getter 方法來儲存狀態的值，並根據業務功能寫上一些來操作這個值。然而，使用 service 時，我們很難跟蹤到狀態的變化情況，還需要做一些額外的程式碼來特別處理。</p>
<p>有時候也會犯懶一下，直接寫一個全局變數。這個時候維護起程式碼來就是一場噩夢，需要全局搜尋相應的變數。如果是呼叫某個特定的 Service 就比較容易找到呼叫的地方。</p>
<h3 id="使用者互動事件">使用者互動：事件</h3>
<p>事實上，對於使用者互動來說也只是改變狀態的值，即對狀態進行操作。</p>
<p>舉一個例子，當使用者點選登入的時候，傳送資料到後臺，由後臺返回這個值。由控制器一一的去修改這些狀態，最後確認這個使用者登入，併發一個使用者已經登入的廣播，又或者修改全局的使用者值。</p>
<h1 id="客戶端儲存藝術資料儲存與模型設定">客戶端儲存藝術：資料儲存與模型設定</h1>
<blockquote>
<p>Web或者移動應用的重心，由後臺往前臺挪動的兩個標誌是：客戶端儲存，客戶端模型維護。在可見的未來，我們將會見證後端將不儲存資料、由前端負責儲存資料的應用。</p>
</blockquote>
<p>寫過一個又一個的應用，我仍然沒有遇到一個業務邏輯複雜的應用。即，我需要在前臺處理一系列複雜的業務邏輯，我需要不斷的轉換前端的資料模型，才能追得上業務的變化。</p>
<p>普通的 Web 應用裡， 前臺只需要負責顯示即可，而後臺相對應的提供資料。後臺每次都為前端提供相應的資料，處理後顯示即可。多數時候，提交的資料也是一次提交，不需要經過複雜的轉換。</p>
<p>而複雜的 Web 應用來說，他們需要大量的使用者互動，由此帶來的複雜度則是模型本身的轉換。JavaScript 本身是一個弱類型的語言，這就意味著在處理模型這方面，它相當的無力。我們需要寫下一個又一個的 <code>語句</code> 來判斷值是否存在？是否是我們想要的結果 ？隨後，我們才真正的去轉換資料。一旦我們需要多次處理這些資料，這就會變成一個災難。</p>
<h2 id="模型與儲存">模型與儲存</h2>
<p>最近，我在寫一個名為 EventStorming.Graph 的圖形工具。因為採用的是強類型的 TypeScript，於是自然而然的就建立了很多的 Model。在這個設計的過程中，儘量採用了 DDD 中的一些思想，如基本的觀察者模式，作為訊息的中心來發布事件。</p>
<figure>
<img src="images/event-storming.png" alt="EventStorming" /><figcaption>EventStorming</figcaption>
</figure>
<p>在這領域裡，有一個基本的內容就是事件。當使用者建立了一個事件的時候，會發現這麼一些事情。在 EventBusiness 中建立了 Observable，並讓監聽相應的 Observer 監聽。有兩個基本的觀察者：</p>
<ul>
<li>儲存。當使用者建立了一個事件的時候，就會從 EB 中獲取到相應的對應，直接儲存到資料庫中。</li>
<li>渲染。當使用者建立了一個事件的時候，我需要把事件以 Sticky（便利貼）的形式渲染到頁面上。這個時候，我需要為事件物件新增一些額外的屬性，如色彩、位置等等，這個時候，它已經不是一個事件模型，而是一個事件便利貼。</li>
</ul>
<p>也因此，我為它建立了一個新的 ID，用來區分舊的便利貼，並且還保留著舊的事件 ID，以便於未來更新物件。隨後，這些資料會被儲存到儲存介質中，並被渲染到頁面上。</p>
<p>作為一個『服務端窮』的我（無力支付起國內的伺服器），就在想儲存的 N 個問題。在客戶端上儲存了儘可能多的資料，只在最後使用者將要離開頁面的時候，向服務端傳送資料——即使用者的 ID、模型的 ID 和模型的內容。</p>
<p>而在客戶端儲存資料，基本上就是兩個問題：資料儲存、模型變化。</p>
<p>客戶端資料儲存是一個簡單的話題，唯一複雜的地方是選用一個比較好的儲存介質。而相應的模型處理，則是一種比較麻煩的事。</p>
<h2 id="儲存">儲存</h2>
<p>客戶端出於不同的原因，我們會儲存一些相應的使用者資料，如：</p>
<ul>
<li>在頁面間共享資料——適用於同一個網站，頁面間使用不同的框架</li>
<li>儲存使用者的 token——快取在記憶體或者 localstorage 用於登入，在重要的操作時再驗證許可權</li>
<li>快取資料，加快下次開啟速度</li>
<li>臨時儲存使用者未完成的表單</li>
<li>儲存 JavaScript 程式碼，以加快開啟速度</li>
</ul>
<p>資料儲存並不是一件很難的事。只需要：</p>
<ol type="1">
<li>選擇一個合適的儲存介質</li>
<li>決定要儲存的資料內容及形式</li>
<li>建立儲存和讀取介面</li>
</ol>
<p>我們只需要想一個 key，再想一個 value 就可以儲存這個值了，如 localStorge 的setItem 和 getItem 就可以輕鬆達到這個要求了。而對於常用的資料格式來說，加上個 <code>JSON.stringify</code> 來轉換物件為字元 串，從 localStorage 中讀取資料時，再用 <code>JSON.parse</code> 去解析即可。</p>
<figure>
<img src="images/localstorage-example.jpg" alt="LocalStorage 示例" /><figcaption>LocalStorage 示例</figcaption>
</figure>
<p>對於 IndexedDB 來說，我們就可以使用物件來儲存了。</p>
<figure>
<img src="images/save-example.jpg" alt="儲存示例" /><figcaption>儲存示例</figcaption>
</figure>
<p>不同的情況下，我們可需要在不同的儲存介質中保持他們了，這個時候只需要不同的介面卡即可。我們可以使用不同的庫來，如支援使用不同介質的 localForge，IndexedDB、WebSQL、localStorage。又或者是支援不同瀏覽器的 store.js。</p>
<p>在客戶端上儲存資料的時候，就那麼幾種情況：</p>
<ul>
<li>單條資料。主要用於儲存一些簡單的資料，如使用者 Token、功能開關、臨時資料等等。</li>
<li>一個模型的資料集合。</li>
<li>多個模型的資料集合。</li>
</ul>
<p>而後，複雜的地方就是處理這些資料模型。</p>
<h2 id="模型的變化">模型的變化</h2>
<p>前端從後臺拿到資料後，這些資料對於後臺來說，就是一個模型。對於後臺來說，這就是從資源庫中讀取單個的 Model 或者 Model 相關的集合放到一起，再用某種 toJSON 方法將他們轉向 JSON。前端拿到這些資料，稍微做一些處理就可以顯示到頁面上。</p>
<p>在一些複雜的例子裡，我們需要做一些特殊的處理。當我們從後臺拿到了兩種不同類型的模型，但是他們繼承了同一個類，結果返回了兩種不同的結果。而在前臺出於業務的需要，我們又需要將這些模型轉為統一的形式。如在一個組織下里存在兩個不同的賬號體系，他們分別由不同的系統（或組織）來管理：</p>
<p>對於 A（普通的使用者） 來說，使用者名稱就是它的手機號，而 Full Name 欄位是它的真實名字。 對於 B （管理員）來說，公司相關的郵箱才是它的使用者名稱，mobile 才是它的手機號。</p>
<p>雖然對於 A 來說，還可能存在一些額外的手機號欄位。但是，使用者名稱才是它真正意義上的手機號，可以用來登入、重置密碼等等的操作。</p>
<p>這個時候，應該要由後臺作一層轉發代理，轉換這些資料，以向前端提供一個一致性的資料。後臺做了一層適配，並提供一個特殊的標誌，用於區分不同的使用者角色。可是問題到了這裡，可能只解決了一半。並帶了一些新的問題，我們需要不斷地處理這些邏輯。</p>
<p>而當我們建立使用者的時候，我們就需要不同的模型來做這件事。不同的客戶端模型，反而變得更加容易了。一個比較典型的場景是：招聘網站。招聘網站分為了兩種角色，公司和個人。這兩種模型唯一的相似之處，怕是有一個唯一的標識符吧。</p>
<h1 id="前端也需要效能優化">前端也需要效能優化</h1>
<h3 id="timeline">Timeline</h3>
<h3 id="首屏載入優化">首屏載入優化</h3>
<h3 id="快取優化">快取優化</h3>
<h3 id="生命週期優化">生命週期優化</h3>
<h3 id="html5-圖片快取">HTML5 圖片快取</h3>
<h3 id="資源快取-api-結果">資源快取， API 結果</h3>
<h1 id="前端移動開發">前端移動開發</h1>
<h2 id="移動開發的三種類型">移動開發的三種類型</h2>
<h3 id="web-應用">Web 應用</h3>
<h3 id="混合應用">混合應用</h3>
<h3 id="react-native">React Native</h3>
<h2 id="響應式設計">響應式設計</h2>
<ol type="1">
<li>優先考慮相容性</li>
</ol>
<p>類似於早期的 moz-border-radius</p>
<p>width calc 100%-60 px</p>
<ol start="2" type="1">
<li><p>em rem px</p></li>
<li><p>居中，居中，居中</p></li>
</ol>
<h2 id="使用者體驗">使用者體驗</h2>
<h2 id="效能">效能</h2>
<h1 id="api-使用-與-設計">API 使用 與 設計 ？</h1>
<h1 id="前端工程化思維">前端工程化思維</h1>
<h2 id="自動化構建">自動化構建</h2>
<h2 id="整合測試">整合測試</h2>
<h1 id="如何以正確的姿勢從零開發一個前端應用">如何以正確的姿勢從零開發一個前端應用</h1>
<h2 id="瞭解真實世界的需求">瞭解真實世界的需求</h2>
<h2 id="確認技術方案">確認技術方案</h2>
<h2 id="選擇技術棧">選擇技術棧</h2>
<h2 id="搭建構建系統">搭建構建系統</h2>
<h2 id="定義前端介面---使用-mock-server">定義前端介面 - 使用 Mock Server</h2>
<p>按優先順序有所不同</p>
<ul>
<li>先需要從 Mockup 中寫入需要的資料 —— 定死</li>
<li>確認需要的介面內容</li>
<li>更新介面到後臺</li>
<li>同步後臺的介面</li>
</ul>
<p>如一些 Related Fields 前端需要的可能是扁平的結果，但是未來可能需要更多的值</p>
<h2 id="實現後臺介面">實現後臺介面</h2>
<h2 id="對接應用編寫測試">對接應用，編寫測試</h2>
<h2 id="上線">上線</h2>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>TC39 是負責 JavaScript 進化的委員會。TC39 定期舉行會議，其會議是由成員公司（主要的瀏覽器廠商）派代表和特邀專家出席了會議。<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>頗受歡迎的個人電腦廠商奧斯本，其公司的創新式便攜電腦還沒有上市，就宣佈他們要推出的更高檔的機器，而又遲遲無法交貨，消費者聞風紛紛停止下單訂購現有機種，最後導致奧斯本因收入枯竭而宣佈破產。<a href="#fnref2">↩</a></p></li>
</ol>
</section>
</body>
</html>
