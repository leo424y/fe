客戶端儲存藝術：資料儲存與模型設定
===

> Web或者移動應用的重心，由後臺往前臺挪動的兩個標誌是：客戶端儲存，客戶端模型維護。在可見的未來，我們將會見證後端將不儲存資料、由前端負責儲存資料的應用。

寫過一個又一個的應用，我仍然沒有遇到一個業務邏輯複雜的應用。即，我需要在前臺處理一系列複雜的業務邏輯，我需要不斷的轉換前端的資料模型，才能追得上業務的變化。

普通的 Web 應用裡， 前臺只需要負責顯示即可，而後臺相對應的提供資料。後臺每次都為前端提供相應的資料，處理後顯示即可。多數時候，提交的資料也是一次提交，不需要經過複雜的轉換。

而複雜的 Web 應用來說，他們需要大量的使用者互動，由此帶來的複雜度則是模型本身的轉換。JavaScript 本身是一個弱類型的語言，這就意味著在處理模型這方面，它相當的無力。我們需要寫下一個又一個的 ``語句`` 來判斷值是否存在？是否是我們想要的結果 ？隨後，我們才真正的去轉換資料。一旦我們需要多次處理這些資料，這就會變成一個災難。

模型與儲存
---

最近，我在寫一個名為 EventStorming.Graph 的圖形工具。因為採用的是強類型的 TypeScript，於是自然而然的就建立了很多的 Model。在這個設計的過程中，儘量採用了 DDD 中的一些思想，如基本的觀察者模式，作為訊息的中心來發布事件。

![EventStorming](../images/event-storming.png)

在這領域裡，有一個基本的內容就是事件。當使用者建立了一個事件的時候，會發現這麼一些事情。在 EventBusiness 中建立了 Observable，並讓監聽相應的 Observer 監聽。有兩個基本的觀察者：

 - 儲存。當使用者建立了一個事件的時候，就會從 EB 中獲取到相應的對應，直接儲存到資料庫中。
 - 渲染。當使用者建立了一個事件的時候，我需要把事件以 Sticky（便利貼）的形式渲染到頁面上。這個時候，我需要為事件物件新增一些額外的屬性，如色彩、位置等等，這個時候，它已經不是一個事件模型，而是一個事件便利貼。

也因此，我為它建立了一個新的 ID，用來區分舊的便利貼，並且還保留著舊的事件 ID，以便於未來更新物件。隨後，這些資料會被儲存到儲存介質中，並被渲染到頁面上。

作為一個『服務端窮』的我（無力支付起國內的伺服器），就在想儲存的 N 個問題。在客戶端上儲存了儘可能多的資料，只在最後使用者將要離開頁面的時候，向服務端傳送資料——即使用者的 ID、模型的 ID 和模型的內容。

而在客戶端儲存資料，基本上就是兩個問題：資料儲存、模型變化。

客戶端資料儲存是一個簡單的話題，唯一複雜的地方是選用一個比較好的儲存介質。而相應的模型處理，則是一種比較麻煩的事。

儲存
---

客戶端出於不同的原因，我們會儲存一些相應的使用者資料，如：

 - 在頁面間共享資料——適用於同一個網站，頁面間使用不同的框架
 - 儲存使用者的 token——快取在記憶體或者 localstorage 用於登入，在重要的操作時再驗證許可權
 - 快取資料，加快下次開啟速度
 - 臨時儲存使用者未完成的表單
 - 儲存 JavaScript 程式碼，以加快開啟速度

資料儲存並不是一件很難的事。只需要：

 1. 選擇一個合適的儲存介質
 2. 決定要儲存的資料內容及形式
 3. 建立儲存和讀取介面

我們只需要想一個 key，再想一個 value 就可以儲存這個值了，如 localStorge 的setItem 和 getItem 就可以輕鬆達到這個要求了。而對於常用的資料格式來說，加上個 ``JSON.stringify`` 來轉換物件為字元 串，從 localStorage 中讀取資料時，再用 ``JSON.parse`` 去解析即可。

![LocalStorage 示例](../images/localstorage-example.jpg)

對於 IndexedDB 來說，我們就可以使用物件來儲存了。

![儲存示例](../images/save-example.jpg)

不同的情況下，我們可需要在不同的儲存介質中保持他們了，這個時候只需要不同的介面卡即可。我們可以使用不同的庫來，如支援使用不同介質的 localForge，IndexedDB、WebSQL、localStorage。又或者是支援不同瀏覽器的 store.js。

在客戶端上儲存資料的時候，就那麼幾種情況：

 - 單條資料。主要用於儲存一些簡單的資料，如使用者 Token、功能開關、臨時資料等等。
 - 一個模型的資料集合。
 - 多個模型的資料集合。

而後，複雜的地方就是處理這些資料模型。

模型的變化
---

前端從後臺拿到資料後，這些資料對於後臺來說，就是一個模型。對於後臺來說，這就是從資源庫中讀取單個的 Model 或者 Model 相關的集合放到一起，再用某種 toJSON 方法將他們轉向 JSON。前端拿到這些資料，稍微做一些處理就可以顯示到頁面上。

在一些複雜的例子裡，我們需要做一些特殊的處理。當我們從後臺拿到了兩種不同類型的模型，但是他們繼承了同一個類，結果返回了兩種不同的結果。而在前臺出於業務的需要，我們又需要將這些模型轉為統一的形式。如在一個組織下里存在兩個不同的賬號體系，他們分別由不同的系統（或組織）來管理：

對於 A（普通的使用者） 來說，使用者名稱就是它的手機號，而 Full Name 欄位是它的真實名字。
對於 B （管理員）來說，公司相關的郵箱才是它的使用者名稱，mobile 才是它的手機號。

雖然對於 A 來說，還可能存在一些額外的手機號欄位。但是，使用者名稱才是它真正意義上的手機號，可以用來登入、重置密碼等等的操作。

這個時候，應該要由後臺作一層轉發代理，轉換這些資料，以向前端提供一個一致性的資料。後臺做了一層適配，並提供一個特殊的標誌，用於區分不同的使用者角色。可是問題到了這裡，可能只解決了一半。並帶了一些新的問題，我們需要不斷地處理這些邏輯。

而當我們建立使用者的時候，我們就需要不同的模型來做這件事。不同的客戶端模型，反而變得更加容易了。一個比較典型的場景是：招聘網站。招聘網站分為了兩種角色，公司和個人。這兩種模型唯一的相似之處，怕是有一個唯一的標識符吧。
